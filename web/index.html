<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <title>Face Anonymizer</title>
    <link id="favicon" rel="icon" type="image/png" sizes="32x32" href="/favicon.png?size=32"/>
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon.png?size=16"/>
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon.png?size=180"/>
    <link rel="manifest" href="/web/manifest.webmanifest"/>
    <meta name="theme-color" content="#0F0F10"/>
    <link rel="mask-icon" href="/web/safari-pinned-tab.svg" color="#0F0F10"/>
    <!-- Tailwind: compiled CSS for production -->
    <link rel="stylesheet" href="/web/assets/tailwind.css"/>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&display=swap" rel="stylesheet"/>
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&display=swap" rel="stylesheet"/>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&display=swap" rel="stylesheet"/>
    <script id="theme-preload">
      (function () {
        try {
          var saved = localStorage.getItem('theme');
          var prefersDark = false;
          try { prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches; } catch(e){}
          var next = saved ? saved : (prefersDark ? 'dark' : 'light');
          var doc = document.documentElement;
          if (next === 'dark') { doc.classList.add('dark'); }
          else { doc.classList.remove('dark'); }
          doc.setAttribute('data-theme', next);
        } catch(e){}
      })();
    </script>
    <script>
      (function() {
        var enable = function(){ try { document.documentElement.classList.add('icons-ready'); } catch(e) {} };
        try {
          if (document.fonts && document.fonts.load) {
            document.fonts.load('24px "Material Symbols Outlined"').then(enable).catch(enable);
          } else {
            enable();
          }
          setTimeout(enable, 2000);
        } catch (e) { enable(); }
      })();
    </script>
    <script id="tailwind-config">
      if (window.tailwind) {
        tailwind.config = {
          darkMode: "class",
          theme: {
            extend: {
              colors: {
                "primary": "#000000",
                "background-main": "#FFFFFF",
                "card-border": "#e5e7eb",
              },
              fontFamily: { "display": ["Space Grotesk", "sans-serif"] },
              borderRadius: { "DEFAULT": "0.25rem", "lg": "0.5rem", "xl": "0.75rem", "full": "9999px" },
            },
          },
        }
      }
    </script>
    <style>
      body { font-family: "Roobert","Space Grotesk",sans-serif; }
      button, [role="button"], .btn { font-family: "JetBrains Mono",ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace !important; letter-spacing: 0.01em; }
      ::selection { background-color: #0F0F10; color: #FFFFFF; }
      ::-moz-selection { background-color: #0F0F10; color: #FFFFFF; }
      .dark ::selection { background-color: #EDEDED; color: #0F0F10; }
      .dark ::-moz-selection { background-color: #EDEDED; color: #0F0F10; }
      body.fullscreen { min-height: 100vh; display: flex; flex-direction: column; }
      body.fullscreen main { margin-top: auto; margin-bottom: auto; }
      #mobileSourceTabs { display: none; }
      .upload-circle {
        width: 64px;
        height: 64px;
        border-radius: 9999px;
        flex: 0 0 auto;
        aspect-ratio: 1 / 1;
        background-color: var(--soft-surface-bg);
        color: var(--soft-surface-fg);
        border: 1px solid var(--soft-surface-border);
      }
      #logoContainer { line-height: 0; flex: 0 0 auto; }
      #headerLogo { display: block; image-rendering: auto; -webkit-backface-visibility: hidden; backface-visibility: hidden; transform: translateZ(0); }
      
      .material-symbols-outlined {
        font-family: "Material Symbols Outlined";
        font-weight: 400;
        font-style: normal;
        line-height: 1em;
        letter-spacing: normal;
        text-transform: none;
        display: inline-block;
        width: 1em;
        height: 1em;
        vertical-align: middle;
        overflow: hidden;
        white-space: nowrap;
        word-wrap: normal;
        direction: ltr;
        -webkit-font-smoothing: antialiased;
        font-variation-settings:
          'FILL' 0,
          'wght' 400,
          'GRAD' 0,
          'opsz' 24;
        visibility: hidden;
      }
      .icons-ready .material-symbols-outlined { visibility: visible; }
      .soft-chip {
        background-color: var(--soft-chip-bg) !important;
        color: var(--soft-chip-fg) !important;
        border: 1px solid var(--soft-surface-border);
        font-family: "Roobert","Space Grotesk",sans-serif;
      }
      /* Layered surface application */
      body { background-color: var(--app-bg) !important; color: var(--text-primary) !important; }
      .dark header { background-color: rgba(23, 23, 23, 0.80) !important; border-color: var(--surface-border) !important; }
      header { border-color: var(--surface-border) !important; }
      .dark #sourceTabs, .dark #mobileSourceTabs { background-color: rgba(23, 23, 23, 0.70) !important; border-color: var(--surface-border) !important; }
      #sourceTabs, #mobileSourceTabs { border-color: var(--surface-border) !important; }
      .dark .glass-panel { background-color: var(--surface-main) !important; border-color: var(--surface-border) !important; }
      .glass-panel { background-color: var(--surface-main) !important; border-color: var(--surface-border) !important; }
      .dark .img-box { background: var(--surface-main) !important; border-color: var(--surface-border) !important; }
      .img-box { background: var(--surface-main) !important; border-color: var(--surface-border) !important; }
      .dark #dropArea { background-color: var(--surface-main) !important; }
      .dark #resultBox { background-color: var(--surface-main) !important; }
      #dropArea { background-color: var(--surface-main) !important; }
      #resultBox { background-color: var(--surface-main) !important; }
      
      /* Text color application */
      .dark body { color: var(--text-primary) !important; }
      #statusText { color: var(--text-muted) !important; }
      .dark #statusText { color: var(--text-muted) !important; }
      #typeSelectBtn { background-color: var(--surface-main) !important; color: var(--text-primary) !important; border-color: var(--surface-border) !important; }
      #typeSelectBtn .select-arrow { color: var(--text-secondary) !important; }
      .dark #typeSelectBtn { background-color: var(--surface-main) !important; color: var(--text-primary) !important; border-color: var(--surface-border) !important; }
      .dark #typeSelectBtn .select-arrow { color: var(--text-secondary) !important; }
      #clearBtn { background-color: var(--surface-elevated) !important; color: var(--text-primary) !important; border-color: var(--surface-border) !important; }
      #clearBtn:hover { background-color: var(--surface-hover) !important; }
      .dark #clearBtn { background-color: var(--surface-main) !important; color: var(--text-primary) !important; border-color: var(--surface-border) !important; }
      .dark #clearBtn:hover { background-color: var(--surface-hover) !important; }
      #downloadBtn[disabled] { background-color: var(--surface-elevated) !important; color: var(--text-disabled) !important; border-color: var(--surface-border) !important; }
      .dark #downloadBtn[disabled] { background-color: var(--surface-elevated) !important; color: var(--text-disabled) !important; border-color: var(--surface-border) !important; }
      .panel-footer { background-color: var(--surface-main); border-top: 1px solid var(--surface-border); }
      .dark .panel-footer { background-color: var(--surface-elevated) !important; border-top-color: var(--surface-border) !important; }
      .toast { background-color: var(--surface-main) !important; color: var(--text-primary) !important; border: 1px solid var(--surface-border) !important; }
      .toast .toast-body p:first-child { color: var(--text-primary) !important; }
      .toast .toast-body p:last-child { color: var(--text-muted) !important; }
      .toast button { color: var(--text-muted) !important; }
      .toast button:hover { color: var(--text-secondary) !important; }
      /* Utility remaps to theme tokens */
      .text-slate-900 { color: var(--text-primary) !important; }
      .text-slate-700 { color: var(--text-secondary) !important; }
      .text-slate-600 { color: var(--text-secondary) !important; }
      .text-slate-500 { color: var(--text-muted) !important; }
      .text-slate-400 { color: var(--text-disabled) !important; }
      .dark .text-slate-100 { color: var(--text-primary) !important; }
      .dark .text-slate-300 { color: var(--text-secondary) !important; }
      .dark .text-slate-400 { color: var(--text-muted) !important; }
      .dark .text-slate-500 { color: var(--text-disabled) !important; }
      #statusText { min-width: 0; max-width: 100%; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; display: block; }
      #progressBarInner { transition: width 240ms cubic-bezier(0.22, 1, 0.36, 1); will-change: width; }
      .border-slate-200 { border-color: var(--surface-border) !important; }
      .dark .border-slate-700 { border-color: var(--surface-border) !important; }
      .bg-slate-50, .bg-slate-100 { background-color: var(--surface-elevated) !important; }
      .dark .bg-slate-900, .dark .bg-slate-800 { background-color: var(--surface-main) !important; }
      /* Cursor hygiene: ensure non-interactive surfaces do not show move cursor */
      body, main, #resultBox, .img-box, video, .panel-footer, #sourceTabs, #mobileSourceTabs { cursor: default !important; }
      /* Result image is clickable for preview */
      #resultBox img.img-main { cursor: pointer !important; }
      /* Upload card should be clickable */
      #dropArea, #dropArea * { cursor: pointer !important; }
      /* Interactive controls use pointer */
      button, [role="button"], .btn, #typeMenu li, #typeSelectBtn, #themeBtn, #downloadBtn, #anonymizeBtn, #clearBtn, #fastModeToggle, label[for="fastModeToggle"] { cursor: pointer !important; }
      /* Hide blinking text caret site-wide */
      html, body, * { caret-color: transparent !important; }
      @media (max-width: 640px) {
        html, body { overflow-y: auto; -webkit-overflow-scrolling: touch; height: auto; }
        html, body { scrollbar-width: none; -ms-overflow-style: none; }
        html::-webkit-scrollbar, body::-webkit-scrollbar { width: 0; height: 0; display: none; }
        header { padding-left: 16px !important; }
        #homeHeaderLink { gap: 0.25rem; }
        #logoContainer { padding: 0.375rem; }
        main { padding: 16px 16px 56px !important; }
        #dropArea { padding-top: 24px !important; padding-bottom: 24px !important; }
        .upload-circle { width: 56px; height: 56px; margin-top: 8px; margin-bottom: 8px; }
        .upload-circle .material-symbols-outlined { font-size: 40px !important; }
        #dropArea button { margin-bottom: 12px; }
        .grid { gap: 10px !important; }
        .img-box { max-height: 60vh; }
        /* prevent over-stretching on phones */
        #dropArea, #resultBox { flex: 0 0 auto !important; min-height: 180px; }
        /* compact footers */
        .panel-footer { height: 44px !important; padding-left: 16px !important; padding-right: 16px !important; }
        /* slimmer download button */
        #downloadBtn { padding-top: 6px !important; padding-bottom: 6px !important; min-height: 36px !important; }
        #downloadBtn .material-symbols-outlined { font-size: 22px !important; }
        #sourceTabs { display: none; }
        #toastContainer {
          left: 50%;
          right: auto !important;
          transform: translateX(-50%);
          top: 72px;
          width: 20rem;
          align-items: center;
        }
        #toastContainer .toast { width: 100%; box-sizing: border-box; }
        #mobileSourceTabs {
          display: flex !important;
          position: static !important;
          margin: 8px auto 12px !important;
          left: auto !important;
          right: auto !important;
          transform: none !important;
          bottom: auto !important;
          z-index: auto !important;
          width: auto !important;
          max-width: min(92vw, 360px) !important;
          padding: 4px !important;
          gap: 0.5rem !important;
          flex-wrap: nowrap !important;
          overflow: hidden !important;
        }
        #mobileSourceTabs button {
          display: inline-flex !important;
          flex: 0 0 auto !important;
          white-space: nowrap !important;
        }
      }
      /* Prevent header overlap between ~640px and tablets */
      @media (min-width: 641px) and (max-width: 750px) {
        #sourceTabs { display: none; }
        #mobileSourceTabs { display: flex !important; margin: 8px auto 12px !important; }
      }
      
      
      :root { --color-primary: #000000; }
      .dark { --color-primary: #ffffff; }
      :root {
        --on-primary: #ffffff;
        --stripe-color: rgba(0, 0, 0, 0.18);
        --soft-chip-bg: rgba(0, 0, 0, 0.06);
        --soft-chip-fg: #0f172a;
        --soft-surface-bg: rgba(0, 0, 0, 0.06);
        --soft-surface-fg: #334155;
        --soft-surface-border: rgba(0, 0, 0, 0.08);
        /* layered surfaces (light, ChatGPT-style) */
        --app-bg: #F7F7F8;
        --surface-main: #FFFFFF;
        --surface-elevated: #F1F1F3;
        --surface-hover: #ECECEF;
        --surface-border: #E1E1E4;
        /* text colors (light, ChatGPT-style) */
        --text-primary: #0F0F10;
        --text-secondary: #4B4B4B;
        --text-muted: #6F6F6F;
        --text-disabled: #9B9B9B;
      }
      .dark {
        --on-primary: #000000;
        --stripe-color: rgba(255, 255, 255, 0.22);
        --soft-chip-bg: rgba(255, 255, 255, 0.12);
        --soft-chip-fg: #e5e7eb;
        --soft-surface-bg: rgba(255, 255, 255, 0.10);
        --soft-surface-fg: #cbd5e1;
        --soft-surface-border: rgba(255, 255, 255, 0.14);
        /* layered surfaces (dark, ChatGPT-style) */
        --app-bg: #0F0F10;
        --surface-main: #171717;
        --surface-elevated: #1F1F1F;
        --surface-hover: #262626;
        --surface-border: #262626;
        /* text colors (dark) */
        --text-primary: #EDEDED;
        --text-secondary: #B4B4B4;
        --text-muted: #8A8A8A;
        --text-disabled: #5C5C5C;
      }
      .custom-dashed-border {
        border: 2px dashed #e5e7eb;
        border-radius: 0.5rem;
      }
      #sourceTabs, #mobileSourceTabs {
        backdrop-filter: blur(6px);
        -webkit-backdrop-filter: blur(6px);
      }
      @supports not (gap: 0.5rem) {
        #sourceTabs { gap: 0 !important; }
        #sourceTabs > button { margin-right: 0.5rem; }
        #sourceTabs > button:last-child { margin-right: 0; }
        #mobileSourceTabs { gap: 0 !important; }
        #mobileSourceTabs > button { margin-right: 0.5rem; }
        #mobileSourceTabs > button:last-child { margin-right: 0; }
      }
      .img-box {
        position: relative;
        aspect-ratio: 16 / 9;
        height: auto;
        min-height: 240px;
        max-height: 60vh;
        border: 1px solid #e5e7eb;
        border-radius: 0.75rem;
        background: #fafafa;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .img-box .bg-blur {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        filter: blur(24px);
        transform: scale(1.1);
        opacity: 0.35;
      }
      .img-box .img-main {
        position: relative;
        max-width: 100%;
        max-height: 100%;
        object-fit: contain;
        border-radius: 0.5rem;
      }
      #headerLogo { transition: filter 160ms ease; }
      .dark #headerLogo { filter: invert(1); }
      @media (prefers-color-scheme: dark) {
        #anonymizeIcon { filter: invert(0); }
      }
      @media (prefers-color-scheme: light) {
        #anonymizeIcon { filter: invert(1); }
      }
      #homeHeaderLink { cursor: pointer; }
      #anonymizeIcon { transition: filter 160ms ease; filter: invert(1); }
      .dark #anonymizeIcon { filter: invert(0); }
      #procDots { display: inline-block; width: 3ch; margin-left: -0.35ch; letter-spacing: 0; word-spacing: 0; line-height: 1; font-kerning: none; font-feature-settings: 'kern' 0; }
      #procDots .dot { visibility: hidden; margin: 0; padding: 0; display: inline-block; }
      #scanDots { display: inline-block; width: 3ch; margin-left: -0.35ch; letter-spacing: 0; word-spacing: 0; line-height: 1; font-kerning: none; font-feature-settings: 'kern' 0; }
      #scanDots .dot { visibility: hidden; margin: 0; padding: 0; display: inline-block; }
      #finalDots { display: inline-block; width: 3ch; margin-left: -0.35ch; letter-spacing: 0; word-spacing: 0; line-height: 1; font-kerning: none; font-feature-settings: 'kern' 0; }
      #finalDots .dot { visibility: hidden; margin: 0; padding: 0; display: inline-block; }
      /* Ensure Processing... in the Anonymize button stays on one line and flush */
      #anonymizeBtn #procDots { display: inline-block; width: 3ch; margin-left: 0; letter-spacing: 0; word-spacing: 0; line-height: 1; white-space: nowrap; font-kerning: none; font-feature-settings: 'kern' 0; }
      #anonymizeBtn #procDots .dot { display: inline-block; visibility: hidden; margin: 0; padding: 0; vertical-align: baseline; }
      /* Keep button ellipsis tight and single-line */
      
      #intensityRange {
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        height: 6px;
        background: #e5e7eb;
        border-radius: 9999px;
        outline: none;
        transition: background 160ms ease;
        margin-top: 6px;
        vertical-align: middle;
      }
      .dark #intensityRange { background: #374151; }
      #intensityRange::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 22px;
        height: 22px;
        border-radius: 50%;
        background: var(--color-primary);
        margin-top: -8px;
        border: none;
        box-shadow: none;
        transition: none;
        transform: none;
      }
      
      #intensityRange:hover::-webkit-slider-thumb { transform: none; }
      #intensityRange:active::-webkit-slider-thumb { transform: none; }
      #intensityRange::-moz-range-thumb {
        width: 22px;
        height: 22px;
        border-radius: 50%;
        background: var(--color-primary);
        border: none;
        box-shadow: none;
        transition: none;
        transform: none;
      }
      
      #intensityRange:hover::-moz-range-thumb { transform: none; }
      #intensityRange:active::-moz-range-thumb { transform: none; }
      #intensityRange::-webkit-slider-runnable-track {
        height: 6px;
        border-radius: 9999px;
      }
      #intensityRange::-moz-range-track {
        height: 6px;
        border-radius: 9999px;
        background: transparent;
        border: none;
      }
      @media (min-width: 768px) {
        #intensityRange {
          flex: 0 0 140px !important;
          width: 140px !important;
        }
      }
      .drop-active { border-color: var(--color-primary); background: rgba(0, 0, 0, 0.06); }
      .dark .drop-active { border-color: var(--color-primary); background: rgba(255, 255, 255, 0.12); }
      .drop-active .size-16 { transform: scale(1.06); }
      .dark .custom-dashed-border { border-color: #374151; }
      .dark .img-box { border-color: #374151; background: #0f172a; }
      .log-panel {
        max-height: 180px;
        overflow: auto;
        border: 1px solid #e5e7eb;
        border-radius: 0.5rem;
        background: #fbfbfb;
        padding: 0.75rem;
      }
      .dark .log-panel {
        border-color: #374151;
        background: #0b1220;
      }
      .ant-shadow {
        box-shadow: 0 6px 16px 0 rgba(0, 0, 0, 0.08), 0 3px 6px -4px rgba(0, 0, 0, 0.12), 0 9px 28px 8px rgba(0, 0, 0, 0.05);
      }
      .toast-enter { transform: translateY(-8px); opacity: 0; }
      .toast-enter-active { transform: translateY(0); opacity: 1; transition: transform 240ms cubic-bezier(0.22, 1, 0.36, 1), opacity 240ms ease-out; }
      .toast-exit { transform: translateY(0); opacity: 1; }
      .toast-exit-active { transform: translateY(-8px); opacity: 0; transition: transform 200ms ease, opacity 200ms ease; }
      .toast { outline: none; }
      .toast:focus-visible { box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.35); border-radius: 0.5rem; }
      .toast-body { word-break: break-word; }
      .bg-success { background-color: #52c41a; }
      .text-success { color: #52c41a; }
      .bg-error { background-color: #ff4d4f; }
      .text-error { color: #ff4d4f; }
      .bg-warning { background-color: #faad14; }
      .text-warning { color: #faad14; }
      .bg-info { background-color: var(--color-primary); }
      .text-info { color: var(--color-primary); }
      .bg-primary { background-color: var(--color-primary) !important; }
      .text-primary { color: var(--color-primary) !important; }
      .text-on-primary { color: var(--on-primary) !important; }
      button:focus, button:focus-visible { outline: none !important; box-shadow: none !important; }
      #downloadBtn:focus, #downloadBtn:focus-visible { outline: none !important; box-shadow: none !important; }
      #sourceTabs button:focus, #sourceTabs button:focus-visible { outline: none !important; box-shadow: none !important; }
      #themeBtn:focus, #themeBtn:focus-visible { outline: none !important; box-shadow: none !important; }
      @keyframes spinOnce { to { transform: rotate(360deg); } }
      .spin-once { display: inline-block; animation: spinOnce 360ms linear; will-change: transform; }
      @keyframes stripeMove { from { background-position: 0 0; } to { background-position: 40px 0; } }
      .bar-stripes { background-image: linear-gradient(45deg, var(--stripe-color) 25%, transparent 25%, transparent 50%, var(--stripe-color) 50%, var(--stripe-color) 75%, transparent 75%, transparent); background-size: 40px 40px; animation: stripeMove 600ms linear infinite; }
      #anonymizeBtn:hover { background-color: var(--color-primary) !important; }
      .tab-indicator {
        transition:
          left 320ms cubic-bezier(0.22, 1, 0.36, 1),
          top 320ms cubic-bezier(0.22, 1, 0.36, 1),
          width 320ms cubic-bezier(0.22, 1, 0.36, 1),
          height 320ms cubic-bezier(0.22, 1, 0.36, 1),
          background-color 200ms ease;
        will-change: left, top, width, height;
      }
      /* Disable indicator animation during initial layout to prevent jump-from-top effect */
      #sourceTabs.indicator-init .tab-indicator,
      #mobileSourceTabs.indicator-init .tab-indicator {
        transition: none !important;
      }
      #typeMenu {
        position: absolute;
        left: 0;
        right: 0;
        bottom: calc(100% + 6px);
        background: var(--surface-main);
        border: 1px solid var(--surface-border);
        border-radius: 0.5rem;
        box-shadow: 0 6px 16px 0 rgba(0, 0, 0, 0.08), 0 3px 6px -4px rgba(0, 0, 0, 0.12), 0 9px 28px 8px rgba(0, 0, 0, 0.05);
        display: none;
        z-index: 50;
        overflow: hidden;
      }
      #typeSelectBtn { width: auto; }
      #typeMenu { min-width: 100%; }
      
      .dark #typeMenu { background: var(--surface-elevated); border-color: var(--surface-border); box-shadow: 0 6px 16px 0 rgba(0, 0, 0, 0.35), 0 3px 6px -4px rgba(0, 0, 0, 0.45), 0 9px 28px 8px rgba(0, 0, 0, 0.35); }
      .select-open #typeMenu { display: block; }
      #typeMenu li {
        padding: 10px 12px;
        font-size: 0.875rem;
        font-weight: 600;
        color: var(--text-primary);
        font-family: "Roobert","Space Grotesk",sans-serif;
        letter-spacing: 0.02em;
        cursor: pointer;
      }
      .dark #typeMenu li { color: var(--text-primary); }
      #typeMenu li:hover, #typeMenu li:focus { background-color: var(--surface-hover); color: var(--text-primary); }
      @keyframes sunToggle {
        0% { transform: rotate(0deg) scale(1); opacity: 0.8; }
        50% { transform: rotate(15deg) scale(1.1); opacity: 1; }
        100% { transform: rotate(0deg) scale(1); opacity: 1; }
      }
      @keyframes moonToggle {
        0% { transform: rotate(0deg) scale(1); opacity: 0.8; }
        50% { transform: rotate(-15deg) scale(1.1); opacity: 1; }
        100% { transform: rotate(0deg) scale(1); opacity: 1; }
      }
      .sun-toggle-anim { animation: sunToggle 320ms ease-out; }
      .moon-toggle-anim { animation: moonToggle 320ms ease-out; }
      @keyframes themeRipple {
        0% { box-shadow: 0 0 0 0 rgba(0, 0, 0, 0.24); }
        100% { box-shadow: 0 0 0 12px rgba(0, 0, 0, 0); }
      }
      .theme-ripple { animation: themeRipple 420ms ease-out; }
      html, body, header, main, .img-box, .glass-panel {
        transition:
          background-color 320ms cubic-bezier(0.22, 1, 0.36, 1),
          color 320ms cubic-bezier(0.22, 1, 0.36, 1),
          border-color 320ms cubic-bezier(0.22, 1, 0.36, 1);
      }
      header, header * {
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        -webkit-touch-callout: none;
      }
      .select-arrow { transition: transform 240ms cubic-bezier(0.22, 1, 0.36, 1); will-change: transform; transform: translateY(-50%) rotate(0deg); }
      .select-open .select-arrow { transform: translateY(-50%) rotate(180deg); }
      #typeSelectBtn[aria-expanded="true"] .select-arrow { transform: translateY(-50%) rotate(180deg); }
      #typeSelect { -webkit-appearance: none; -moz-appearance: none; appearance: none; background-image: none; }
      #typeSelect::-ms-expand { display: none; }
      .control-label { display: inline-block; line-height: 1; margin-left: 0; }
      #intensityLabel { position: relative; top: 2px; }
      #fastModeToggle { accent-color: var(--color-primary) !important; }
      #fastModeToggle:focus { outline: none; box-shadow: none; }
      #fastModeToggle:focus-visible { outline: none; box-shadow: none; }
      input[type="checkbox"], input[type="radio"], input[type="range"] { accent-color: var(--color-primary) !important; }
      #fastModeToggle {
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
        width: 1.5rem;
        height: 1.5rem;
        border: 1px solid var(--color-primary);
        border-radius: 0;
        background-color: transparent;
        background-image: none !important;
        position: relative;
        transition: background-color 160ms ease, border-color 160ms ease;
      }
      #fastModeToggle { border-color: #e5e7eb; }
      .dark #fastModeToggle { border-color: #374151; }
      #fastModeToggle:checked {
        background-color: var(--color-primary);
        background-image: none !important;
      }
      #fastModeToggle:checked::after {
        content: "";
        position: absolute;
        width: 7px;
        height: 10px;
        border: 2px solid var(--on-primary);
        border-top: none;
        border-left: none;
        transform: translate(-50%, -60%) rotate(45deg);
        left: 50%;
        top: 50%;
      }
    </style>
  </head>
  <body class="bg-white text-slate-900 dark:bg-slate-900 dark:text-slate-100 min-h-screen">
    <div class="layout-container flex h-full grow flex-col">
      <header class="grid grid-cols-[1fr_auto_1fr] items-center whitespace-nowrap border-b border-solid border-slate-200 dark:border-slate-700 px-12 lg:px-20 py-4 bg-white/80 dark:bg-slate-900/80 backdrop-blur-md sticky top-0 z-50">
        <div id="homeHeaderLink" class="flex items-center gap-1">
          <div id="logoContainer" class="p-2 flex items-center justify-center shrink-0">
            <img id="headerLogo" src="/web/logo.png" srcset="/web/logo.png 1x, /web/logo.png 2x, /web/logo.png 3x" sizes="48px" width="48" height="48" alt="Face Anonymizer logo" class="h-12 w-12 object-contain block shrink-0" title="Face Anonymizer" loading="eager" decoding="async" fetchpriority="high" />
          </div>
          <h2 class="text-xl font-bold leading-tight tracking-tight text-slate-900 dark:text-slate-100">Face Anonymizer</h2>
        </div>
        <div class="flex items-center justify-center justify-self-center">
          <div id="sourceTabs" class="relative flex items-center gap-2 rounded-full bg-white/70 dark:bg-slate-800/70 border border-slate-200 dark:border-slate-700 p-1 shadow-sm backdrop-blur-sm transition-colors">
            <span id="tabIndicator" class="absolute rounded-full bg-primary tab-indicator" style="z-index:0; top:0; left:0; height:0; width:0;"></span>
            <button id="tabImage" class="px-6 h-10 rounded-full font-bold text-sm leading-none text-on-primary relative z-10 transition-colors flex items-center">Image</button>
            <button id="tabVideo" class="px-6 h-10 rounded-full font-bold text-sm leading-none text-slate-700 dark:text-slate-300 relative z-10 transition-colors flex items-center">Video</button>
          </div>
        </div>
        <div class="flex items-center gap-4 justify-self-end">
          <button id="themeBtn" class="relative overflow-hidden flex items-center justify-center rounded-lg h-10 w-10 text-slate-600 dark:text-slate-300 transition-colors" title="Appearance">
            <span id="themeIcon" class="material-symbols-outlined text-[32px]">light_mode</span>
          </button>
        </div>
      </header>
      <div id="mobileSourceTabs" class="relative flex items-center gap-2 rounded-full bg-white/70 dark:bg-slate-800/70 border border-slate-200 dark:border-slate-700 p-1 shadow-sm backdrop-blur-sm">
        <span id="tabIndicatorMobile" class="absolute rounded-full bg-primary tab-indicator" style="z-index:0; top:0; left:0; height:0; width:0;"></span>
        <button id="tabImageMobile" class="px-6 h-10 rounded-full font-bold text-sm leading-none text-on-primary relative z-10 transition-colors flex items-center">Image</button>
        <button id="tabVideoMobile" class="px-6 h-10 rounded-full font-bold text-sm leading-none text-slate-700 dark:text-slate-300 relative z-10 transition-colors flex items-center">Video</button>
      </div>
      <main class="max-w-[1200px] mx-auto w-full p-4 lg:p-8">
        <div class="flex flex-col gap-1.5 mb-2">
          <h1 class="text-2xl md:text-3xl font-bold tracking-tight text-slate-900 dark:text-slate-100">Face Anonymizer</h1>
          <p class="text-slate-600 text-base max-w-xl mb-4">
            High-performance face anonymization for images and videos. All processing happens locally — nothing is uploaded.
          </p>
        </div>
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-7 mb-7">
          <div class="flex flex-col gap-4">
            <div class="flex items-center justify-between px-2">
              <div class="flex items-center gap-2">
                <span class="material-symbols-outlined text-[32px] text-primary">upload_file</span>
                <h3 id="inputHeading" class="text-lg font-bold text-slate-900 dark:text-slate-100">Original Image</h3>
              </div>
              <span class="text-xs font-semibold soft-chip px-2.5 py-1 rounded-full uppercase tracking-wider">Original</span>
            </div>
            <div class="bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-xl overflow-hidden shadow-sm flex flex-col min-h-[300px] md:min-h-[360px] glass-panel dark:bg-slate-800">
              <div class="flex-1 p-6 md:p-8 flex flex-col">
                <div id="dropArea" class="flex-1 img-box custom-dashed-border bg-slate-50 dark:bg-slate-900 transition-all cursor-pointer flex flex-col items-center justify-center gap-4 text-center p-6 md:p-8">
                  <div class="upload-circle bg-slate-200 text-slate-600 flex items-center justify-center transition-transform">
                    <span class="material-symbols-outlined text-5xl">add_photo_alternate</span>
                  </div>
                  <div>
                    <p class="text-sm font-semibold text-slate-900 dark:text-slate-100">Click or drag an image here</p>
                    <p class="text-xs text-slate-500 mt-1">Supported formats: JPG, PNG, WEBP, BMP, TIFF · Max 10 MB</p>
                  </div>
                  <input id="fileInput" type="file" accept="image/jpeg,image/png,image/webp,image/bmp,image/tiff" class="hidden" />
                </div>
              </div>
              <div class="px-6 h-16 bg-slate-50 dark:bg-slate-900 border-t border-slate-200 dark:border-slate-700 flex justify-between items-center panel-footer">
                <span id="statusText" class="text-xs text-slate-500 italic">No file uploaded yet</span>
              </div>
            </div>
          </div>
          <div class="flex flex-col gap-4">
            <div class="flex items-center justify-between px-2">
              <div class="flex items-center gap-2">
                <span class="material-symbols-outlined text-[32px]">verified_user</span>
                <h3 class="text-lg font-bold text-slate-900 dark:text-slate-100">Anonymized Result</h3>
              </div>
              <span class="text-xs font-semibold soft-chip px-2.5 py-1 rounded-full uppercase tracking-wider">Result</span>
            </div>
            <div class="bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-xl overflow-hidden shadow-sm flex flex-col min-h-[300px] md:min-h-[360px] glass-panel dark:bg-slate-800">
              <div class="flex-1 p-6 md:p-8 flex flex-col relative overflow-hidden group">
                <div id="resultBox" class="flex-1 bg-slate-50 dark:bg-slate-900 rounded-lg flex flex-col items-center justify-center gap-4 text-center img-box p-6 md:p-8">
                  <div class="upload-circle bg-slate-200 text-slate-600 flex items-center justify-center transition-transform">
                    <span class="material-symbols-outlined text-5xl">visibility_off</span>
                  </div>
                  <p class="text-xs px-12 text-slate-500">Your anonymized image will appear here</p>
                </div>
              </div>
              <div class="px-6 h-16 bg-slate-50 dark:bg-slate-900 border-t border-slate-200 dark:border-slate-700 flex items-center justify-end panel-footer">
                <button id="downloadBtn" class="flex items-center gap-2 px-4 py-2 bg-slate-100 dark:bg-slate-800 text-slate-400 dark:text-slate-500 border border-slate-200 dark:border-slate-700 rounded-lg text-sm font-bold cursor-not-allowed pointer-events-none" disabled>
                  <span class="material-symbols-outlined text-[26px]">download</span>
                  Download
                </button>
              </div>
              
            </div>
          </div>
        </div>
        <div class="bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-2xl p-6 shadow-sm glass-panel dark:bg-slate-800">
          <div class="flex flex-col lg:flex-row items-center gap-6 lg:gap-8 lg:justify-center">
            <div class="flex flex-col md:flex-row items-start gap-6 md:gap-10 lg:gap-12 w-full lg:w-auto">
              <div class="flex flex-col gap-2 py-2 w-full md:w-56">
                <label class="control-label text-xs font-bold text-slate-500 uppercase tracking-wider">Anonymization Type</label>
                <div id="typeSelectWrapper" class="relative">
                  <input id="typeSelect" type="hidden" value="blur" />
                  <button id="typeSelectBtn" type="button" class="w-full bg-slate-50 dark:bg-slate-900 border-slate-200 dark:border-slate-700 text-slate-900 dark:text-slate-100 border rounded-lg py-3 pl-3 pr-10 text-sm font-medium focus:ring-2 focus:ring-primary focus:border-primary transition-all relative flex items-center" aria-expanded="false" aria-haspopup="listbox" aria-controls="typeMenu">
                    <span id="typeSelectText">Gaussian Blur</span>
                    <span class="material-symbols-outlined select-arrow text-slate-500 dark:text-slate-400 absolute right-3 top-1/2 -translate-y-1/2 pointer-events-none">expand_more</span>
                  </button>
                  <ul id="typeMenu" role="listbox" aria-label="Anonymization Type">
                    <li role="option" tabindex="0" data-value="blur">Gaussian Blur</li>
                    <li role="option" tabindex="0" data-value="pixelate">Pixelation Grid</li>
                    <li role="option" tabindex="0" data-value="black_bar">Censored Black Bar</li>
                  </ul>
                </div>
              </div>
              <div class="flex flex-col gap-2 py-2 w-full md:w-40">
                <label class="control-label text-xs font-bold text-slate-500 uppercase tracking-wider">Intensity</label>
                <div class="flex items-center gap-2 py-3">
                  <input id="intensityRange" class="flex-1 accent-primary h-1.5 bg-slate-200 rounded-full cursor-pointer" max="100" min="5" type="range" value="40"/>
                  <span id="intensityLabel" class="text-xs font-bold text-slate-900 dark:text-slate-100 w-10">40%</span>
                </div>
              </div>
              <div class="flex flex-col gap-2 py-2 w-full md:w-64 md:ml-6 lg:ml-10">
                <label class="control-label text-xs font-bold text-slate-500 uppercase tracking-wider">Fast Mode</label>
                <div class="flex items-center gap-2 py-3">
                  <input id="fastModeToggle" type="checkbox" class="focus:outline-none focus:ring-0 appearance-none"/>
                  <label for="fastModeToggle" class="text-[15px] text-slate-600 dark:text-slate-300 whitespace-nowrap">Faster result, lower quality</label>
                </div>
              </div>
            </div>
            <div class="flex flex-col sm:flex-row items-center justify-center gap-3 w-full lg:w-auto pt-2 lg:pt-0 self-center mx-auto">
              <button id="anonymizeBtn" class="w-full sm:w-auto flex items-center justify-center gap-2 px-8 py-4 bg-primary hover:bg-primary/90 text-on-primary rounded-xl font-bold transition-all shadow-lg shadow-primary/20 active:scale-[0.98] focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2 focus:ring-offset-white dark:focus:ring-offset-slate-900 border border-transparent">
                <span id="anonymizeText" class="leading-none">Anonymize</span>
              </button>
              <button id="clearBtn" class="w-full sm:w-auto flex items-center justify-center px-6 py-4 bg-slate-100 hover:bg-slate-200 text-slate-700 border border-slate-200 rounded-xl font-bold transition-all dark:bg-slate-800 dark:hover:bg-slate-700 dark:text-slate-200 dark:border-slate-700 focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2 focus:ring-offset-white dark:focus:ring-offset-slate-900">
                Clear
              </button>
            </div>
          </div>
        </div>
      </main>
      <div id="toastContainer" class="fixed top-20 right-8 z-[100] flex flex-col gap-4 w-80 pointer-events-none" role="region" aria-live="polite" aria-label="Notifications and alerts"></div>
      <!--
      <section class="max-w-[1200px] mx-auto w-full px-6 lg:px-10 pb-10">
        <div class="bg-white dark:bg-slate-800 border border-slate-200 dark:border-slate-700 rounded-2xl p-4 shadow-sm">
          <div class="flex justify-between items-center mb-3">
            <h4 class="text-sm font-bold text-slate-700 dark:text-slate-200">Logs</h4>
            <div class="flex gap-2">
              <button id="copyLogsBtn" class="px-3 py-1.5 bg-slate-100 dark:bg-slate-900 text-slate-700 dark:text-slate-200 border border-slate-200 dark:border-slate-700 rounded-md text-xs font-bold">Copy</button>
              <button id="clearLogsBtn" class="px-3 py-1.5 bg-slate-100 dark:bg-slate-900 text-slate-700 dark:text-slate-200 border border-slate-200 dark:border-slate-700 rounded-md text-xs font-bold">Clear</button>
            </div>
          </div>
          <div id="errorLog" class="log-panel text-xs font-mono text-slate-700 dark:text-slate-200"></div>
        </div>
      </section>
      -->
    </div>
    <script>
      const themeBtn = document.getElementById('themeBtn');
      const themeIcon = document.getElementById('themeIcon');
      const homeHeaderLink = document.getElementById('homeHeaderLink');
      const fileInput = document.getElementById('fileInput');
      const browseBtn = document.getElementById('browseBtn');
      const dropArea = document.getElementById('dropArea');
      const statusText = document.getElementById('statusText');
      const resultBox = document.getElementById('resultBox');
      const anonymizeBtn = document.getElementById('anonymizeBtn');
      const clearBtn = document.getElementById('clearBtn');
      const intensityRange = document.getElementById('intensityRange');
      const intensityLabel = document.getElementById('intensityLabel');
      const typeSelect = document.getElementById('typeSelect');
      const downloadBtn = document.getElementById('downloadBtn');
      const previewBtn = document.getElementById('previewBtn');
      const tabImage = document.getElementById('tabImage');
      const tabVideo = document.getElementById('tabVideo');
      const sourceTabs = document.getElementById('sourceTabs');
      const tabIndicator = document.getElementById('tabIndicator');
      const tabImageMobile = document.getElementById('tabImageMobile');
      const tabVideoMobile = document.getElementById('tabVideoMobile');
      const mobileSourceTabs = document.getElementById('mobileSourceTabs');
      const tabIndicatorMobile = document.getElementById('tabIndicatorMobile');
      const logView = document.getElementById('errorLog');
      const copyLogsBtn = document.getElementById('copyLogsBtn');
      const clearLogsBtn = document.getElementById('clearLogsBtn');
      const inputHeading = document.getElementById('inputHeading');
      
      let dropClickHandler = null;

      let selectedFile = null;
      let resultBlobUrl = null;
      let resultBlobMime = '';
      let selectedPreviewUrl = null;
      let selectedVideoPosterUrl = null;
      let reprocTimer = null;
      let processingAnimTimer = null;
      let processingAnimStep = 0;
      let scanAnimTimer = null;
      let finalizeAnimTimer = null;
      let scanAnimStep = 0;
      let finalizeAnimStep = 0;
      let progressTimer = null;
      let progressValue = 0;
      let progressStartTime = 0;
      let processingToast = null;
      let lastProgressDisplay = 0;
      function setTabsInteractivity(enabled) {
        const st = document.getElementById('sourceTabs');
        const mst = document.getElementById('mobileSourceTabs');
        if (enabled) {
          if (st) { st.style.pointerEvents = 'auto'; st.removeAttribute('aria-disabled'); }
          if (mst) { mst.style.pointerEvents = 'auto'; mst.removeAttribute('aria-disabled'); }
        } else {
          if (st) { st.style.pointerEvents = 'none'; st.setAttribute('aria-disabled','true'); }
          if (mst) { mst.style.pointerEvents = 'none'; mst.setAttribute('aria-disabled','true'); }
        }
      }
      function lockButtonSize(btn) {
        if (!btn) return;
        const w = Math.round(btn.offsetWidth);
        const h = Math.round(btn.offsetHeight);
        btn.style.minWidth = w + 'px';
        btn.style.minHeight = h + 'px';
      }
      function equalizeButtons() {
        if (!anonymizeBtn || !clearBtn) return;
        const ah = Math.round(anonymizeBtn.offsetHeight);
        const ch = Math.round(clearBtn.offsetHeight);
        const h = Math.max(ah, ch);
        anonymizeBtn.style.minHeight = h + 'px';
        clearBtn.style.minHeight = h + 'px';
      }
      requestAnimationFrame(equalizeButtons);
      window.addEventListener('resize', () => { equalizeButtons(); });
      function setAnonymizeBaseWidth() {
        if (!anonymizeBtn) return;
        const p = document.createElement('span');
        p.style.position = 'absolute';
        p.style.visibility = 'hidden';
        p.style.pointerEvents = 'none';
        p.style.whiteSpace = 'nowrap';
        p.className = '';
        p.innerHTML = 'Processing <span id="tmpDots"><span>.</span><span>.</span><span>.</span></span>';
        anonymizeBtn.appendChild(p);
        const w2 = Math.round(p.offsetWidth);
        p.remove();
        const a = document.createElement('span');
        a.style.position = 'absolute';
        a.style.visibility = 'hidden';
        a.style.pointerEvents = 'none';
        a.style.whiteSpace = 'nowrap';
        a.textContent = 'Anonymize';
        anonymizeBtn.appendChild(a);
        const w1 = Math.round(a.offsetWidth);
        a.remove();
        const w = Math.max(w1, w2);
        if (w > 0) anonymizeBtn.style.minWidth = w + 32 + 'px';
      }
      requestAnimationFrame(() => { setTimeout(setAnonymizeBaseWidth, 0); });
      let busy = false;
      window.addEventListener('beforeunload', (e) => {
        if (busy || resultBlobUrl) {
          e.preventDefault();
          e.returnValue = 'Your anonymized result will be cleared if you refresh or leave.';
        }
      });
      let currentAbortController = null;
      const logs = [];
      let source = 'image';
      const MIN_PROCESS_MS = 800;
      // Realistic progress messaging based on phase and percent
      let progressKind = '';
      let progressPhase = '';
      function updateProgressLabelByPercent(kind, percent) {
        const lbl = document.getElementById('progressLabel');
        if (!lbl) return;
        const p = Math.max(0, Math.min(100, Math.round(percent)));
        let next = '';
        if (kind === 'image') {
          if (p < 10) next = 'Preparing image';
          else if (p < 40) next = 'Detecting faces';
          else if (p < 80) next = 'Applying anonymization';
          else if (p < 95) next = 'Rendering result';
          else next = 'Finalizing';
        } else if (kind === 'video') {
          if (p < 20) next = 'Preparing frames';
          else if (p < 50) next = 'Detecting faces';
          else if (p < 85) next = 'Blurring faces';
          else if (p < 95) next = 'Encoding video';
          else next = 'Finalizing';
        } else {
          next = lbl.textContent || 'Processing';
        }
        if (next && next !== progressPhase) {
          lbl.textContent = next;
          progressPhase = next;
        }
      }
      const metricFaces = () => document.getElementById('metricFaces');
      const metricTime = () => document.getElementById('metricTime');
      const metricType = () => document.getElementById('metricType');
      const metricStatus = () => document.getElementById('metricStatus');
      const ALLOWED_IMAGE_TYPES = ['image/jpeg','image/png','image/webp','image/bmp','image/tiff'];
      const ALLOWED_IMAGE_EXT = ['.jpg','.jpeg','.png','.webp','.bmp','.tif','.tiff'];
      const ALLOWED_VIDEO_TYPES = ['video/mp4','video/webm','video/quicktime','video/x-msvideo','video/hevc'];
      const ALLOWED_VIDEO_EXT = ['.mp4','.webm','.mov','.avi','.hevc'];
      
      function extOf(name) { const i = name.lastIndexOf('.'); return i >= 0 ? name.slice(i).toLowerCase() : ''; }
      function canPlayVideoType(t) { const v = document.createElement('video'); return !!(v.canPlayType && v.canPlayType(t)); }
      function startProgress(kind) {
        progressValue = 0;
        lastProgressDisplay = 0;
        progressStartTime = performance.now();
        const label = 'Scan for faces';
        resultBox.innerHTML = `
          <div class="w-full mx-auto flex flex-col items-center justify-center gap-3 p-4" style="width: min(100%, 260px);">
            <p id="progressLabel" class="text-sm font-semibold text-slate-900 dark:text-slate-100">${label}</p>
            <div id="progressBarWrap" class="relative w-full h-2 rounded-full bg-slate-200 dark:bg-slate-800 overflow-hidden border border-slate-300 dark:border-slate-700">
              <div id="progressBarInner" class="h-full bg-primary transition-all" style="width: 0%;"></div>
              <div id="progressStripe" class="absolute inset-0 rounded-full bar-stripes" style="display:none;"></div>
            </div>
            <span id="progressPercent" class="text-xs font-bold text-slate-700 dark:text-slate-300">0%</span>
          </div>
        `;
        if (progressTimer) { clearInterval(progressTimer); }
        progressTimer = setInterval(() => {
          const step = progressValue < 80 ? 2 : 1;
          progressValue = Math.min(95, progressValue + step);
          const bar = document.getElementById('progressBarInner');
          const pct = document.getElementById('progressPercent');
          const stripe = document.getElementById('progressStripe');
          const disp = Math.max(lastProgressDisplay, progressValue);
          lastProgressDisplay = disp;
          if (bar) bar.style.width = disp + '%';
          if (pct) {
            if (disp >= 95) {
              if (finalizeAnimTimer) { clearInterval(finalizeAnimTimer); finalizeAnimTimer = null; }
              pct.innerHTML = '<span id="finalDots"><span class="dot">.</span><span class="dot">.</span><span class="dot">.</span></span>';
              finalizeAnimStep = 0;
              finalizeAnimTimer = setInterval(() => {
                const dots = document.querySelectorAll('#finalDots .dot');
                if (!dots || dots.length === 0) return;
                finalizeAnimStep = (finalizeAnimStep + 1) % 3;
                dots.forEach((d, i) => { d.style.visibility = i <= finalizeAnimStep ? 'visible' : 'hidden'; });
              }, 500);
            } else {
              if (finalizeAnimTimer) { clearInterval(finalizeAnimTimer); finalizeAnimTimer = null; }
              pct.textContent = Math.round(disp) + '%';
            }
          }
          if (stripe) stripe.style.display = progressValue >= 95 ? 'block' : 'none';
        }, 120);
      }
      function finishProgress() {
        if (progressTimer) { clearInterval(progressTimer); progressTimer = null; }
        if (finalizeAnimTimer) { clearInterval(finalizeAnimTimer); finalizeAnimTimer = null; }
        progressKind = '';
        progressPhase = '';
        const bar = document.getElementById('progressBarInner');
        const pct = document.getElementById('progressPercent');
        const stripe = document.getElementById('progressStripe');
        lastProgressDisplay = 100;
        if (bar) bar.style.width = '100%';
        if (pct) pct.textContent = '100%';
        if (stripe) stripe.style.display = 'none';
        setTabsInteractivity(true);
      }
      function showResultPlaceholder() {
        if (progressTimer) { clearInterval(progressTimer); progressTimer = null; }
        if (scanAnimTimer) { clearInterval(scanAnimTimer); scanAnimTimer = null; }
        progressValue = 0;
        lastProgressDisplay = 0;
        progressKind = '';
        progressPhase = '';
        resultBox.innerHTML = `<div class="upload-circle bg-slate-200 text-slate-600 flex items-center justify-center transition-transform"><span class="material-symbols-outlined text-5xl">visibility_off</span></div><p class="text-xs px-12 text-slate-500">Your anonymized image will appear here</p>`;
      }
      function startChecking(kind) {
        progressValue = 0;
        lastProgressDisplay = 0;
        progressStartTime = performance.now();
        const label = 'Scanning for faces';
        resultBox.innerHTML = `
          <div class="w-full mx-auto flex flex-col items-center justify-center gap-3 p-4" style="width: min(100%, 260px);">
            <p class="text-sm font-semibold text-slate-900 dark:text-slate-100">${label}<span id="scanDots"><span class="dot">.</span><span class="dot">.</span><span class="dot">.</span></span></p>
          </div>
        `;
        if (progressTimer) { clearInterval(progressTimer); progressTimer = null; }
        if (scanAnimTimer) { clearInterval(scanAnimTimer); scanAnimTimer = null; }
        scanAnimStep = 0;
        const dotsTick = () => {
          const dots = resultBox.querySelectorAll('#scanDots .dot');
          if (!dots || dots.length === 0) return;
          scanAnimStep = (scanAnimStep + 1) % 3;
          dots.forEach((d, i) => { d.style.visibility = i <= scanAnimStep ? 'visible' : 'hidden'; });
        };
        scanAnimTimer = setInterval(dotsTick, 500);
      }
      function startUploadProgress(kind) {
        if (scanAnimTimer) { clearInterval(scanAnimTimer); scanAnimTimer = null; }
        if (finalizeAnimTimer) { clearInterval(finalizeAnimTimer); finalizeAnimTimer = null; }
        progressValue = 0;
        lastProgressDisplay = 0;
        progressStartTime = performance.now();
        const label = kind === 'video' ? 'Uploading video' : 'Uploading image';
        resultBox.innerHTML = `
          <div class="w-full mx-auto flex flex-col items-center justify-center gap-3 p-4" style="width: min(100%, 260px);">
            <p id="progressLabel" class="text-sm font-semibold text-slate-900 dark:text-slate-100">${label}</p>
            <div id="progressBarWrap" class="relative w-full h-2 rounded-full bg-slate-200 dark:bg-slate-800 overflow-hidden border border-slate-300 dark:border-slate-700">
              <div id="progressBarInner" class="h-full bg-primary transition-all" style="width: 0%;"></div>
              <div id="progressStripe" class="absolute inset-0 rounded-full bar-stripes" style="display:none;"></div>
            </div>
            <span id="progressPercent" class="text-xs font-bold text-slate-700 dark:text-slate-300">0%</span>
          </div>
        `;
        if (progressTimer) { clearInterval(progressTimer); progressTimer = null; }
      }
      function setProgressBar(value, labelText) {
        const v = Math.max(0, Math.min(100, Number(value) || 0));
        const nv = Math.max(lastProgressDisplay || 0, v);
        lastProgressDisplay = nv;
        const bar = document.getElementById('progressBarInner');
        const pct = document.getElementById('progressPercent');
        if (bar) bar.style.width = nv + '%';
        if (pct) {
          if (nv >= 95) {
            if (!pct.getAttribute('data-finalizing')) {
              pct.setAttribute('data-finalizing', '1');
              pct.innerHTML = 'Finalizing<span id="finalDots"><span class="dot">.</span><span class="dot">.</span><span class="dot">.</span></span>';
              finalizeAnimStep = 0;
              try {
                const dotsNow = document.querySelectorAll('#finalDots .dot');
                if (dotsNow && dotsNow.length) {
                  dotsNow.forEach((d, i) => { d.style.visibility = i === 0 ? 'visible' : 'hidden'; });
                }
              } catch {}
              if (!finalizeAnimTimer) {
                finalizeAnimTimer = setInterval(() => {
                  const dots = document.querySelectorAll('#finalDots .dot');
                  if (!dots || dots.length === 0) return;
                  finalizeAnimStep = (finalizeAnimStep + 1) % 3;
                  dots.forEach((d, i) => { d.style.visibility = i <= finalizeAnimStep ? 'visible' : 'hidden'; });
                }, 500);
              }
            }
          } else {
            pct.removeAttribute('data-finalizing');
            if (finalizeAnimTimer) { clearInterval(finalizeAnimTimer); finalizeAnimTimer = null; }
            pct.textContent = Math.round(nv) + '%';
          }
        }
        const lbl = document.getElementById('progressLabel');
        if (labelText && lbl) {
          lbl.textContent = labelText;
          progressPhase = '';
        } else if (!labelText && lbl && progressKind) {
          updateProgressLabelByPercent(progressKind, nv);
        }
      }
      function beginProcessingProgress(kind) {
        const lbl = document.getElementById('progressLabel');
        if (!lbl) {
          // Create progress UI lazily so we only show it after success
          const k = kind === 'video' ? 'Processing video' : 'Processing image';
          try {
            resultBox.innerHTML = `
              <div class="w-full mx-auto flex flex-col items-center justify-center gap-3 p-4" style="width: min(100%, 260px);">
                <p id="progressLabel" class="text-sm font-semibold text-slate-900 dark:text-slate-100">${k}</p>
                <div id="progressBarWrap" class="relative w-full h-2 rounded-full bg-slate-200 dark:bg-slate-800 overflow-hidden border border-slate-300 dark:border-slate-700">
                  <div id="progressBarInner" class="h-full bg-primary transition-all" style="width: 0%;"></div>
                  <div id="progressStripe" class="absolute inset-0 rounded-full bar-stripes" style="display:none;"></div>
                </div>
                <span id="progressPercent" class="text-xs font-bold text-slate-700 dark:text-slate-300">0%</span>
              </div>
            `;
          } catch {}
        } else {
          lbl.textContent = kind === 'video' ? 'Processing video' : 'Processing image';
        }
        progressKind = kind;
        progressPhase = '';
        progressValue = Math.max(Number(lastProgressDisplay || 0), 5);
        if (progressTimer) { clearInterval(progressTimer); }
        progressTimer = setInterval(() => {
          const step = progressValue < 80 ? 2 : 1;
          progressValue = Math.min(95, progressValue + step);
          const bar = document.getElementById('progressBarInner');
          const pct = document.getElementById('progressPercent');
          const stripe = document.getElementById('progressStripe');
          const disp = Math.max(lastProgressDisplay, progressValue);
          lastProgressDisplay = disp;
          if (bar) bar.style.width = disp + '%';
          if (pct) {
            if (disp >= 95) {
              if (!pct.getAttribute('data-finalizing')) {
                pct.setAttribute('data-finalizing', '1');
                pct.innerHTML = 'Finalizing<span id="finalDots"><span class="dot">.</span><span class="dot">.</span><span class="dot">.</span></span>';
                finalizeAnimStep = 0;
                try {
                  const dotsNow = document.querySelectorAll('#finalDots .dot');
                  if (dotsNow && dotsNow.length) {
                    dotsNow.forEach((d, i) => { d.style.visibility = i === 0 ? 'visible' : 'hidden'; });
                  }
                } catch {}
                if (!finalizeAnimTimer) {
                  finalizeAnimTimer = setInterval(() => {
                    const dots = document.querySelectorAll('#finalDots .dot');
                    if (!dots || dots.length === 0) return;
                    finalizeAnimStep = (finalizeAnimStep + 1) % 3;
                    dots.forEach((d, i) => { d.style.visibility = i <= finalizeAnimStep ? 'visible' : 'hidden'; });
                  }, 500);
                }
              }
            } else {
              if (finalizeAnimTimer) { clearInterval(finalizeAnimTimer); finalizeAnimTimer = null; }
              if (pct.getAttribute('data-finalizing')) pct.removeAttribute('data-finalizing');
              pct.textContent = Math.round(disp) + '%';
            }
          }
          if (stripe) stripe.style.display = progressValue >= 95 ? 'block' : 'none';
          if (progressKind) { updateProgressLabelByPercent(progressKind, disp); }
        }, 120);
        
      }
      function readHead(file, n = 32) {
        return new Promise((resolve, reject) => {
          const r = new FileReader();
          r.onerror = () => reject(new Error('Read error'));
          r.onload = () => resolve(new Uint8Array(r.result));
          r.readAsArrayBuffer(file.slice(0, n));
        });
      }
      async function sniffImage(file) {
        try {
          const b = await readHead(file, 16);
          if (b.length >= 2 && b[0] === 0xFF && b[1] === 0xD8) return true;
          if (b.length >= 8 && b[0] === 0x89 && b[1] === 0x50 && b[2] === 0x4E && b[3] === 0x47 && b[4] === 0x0D && b[5] === 0x0A && b[6] === 0x1A && b[7] === 0x0A) return true;
          if (b.length >= 12 && String.fromCharCode(b[0],b[1],b[2],b[3]) === 'RIFF' && String.fromCharCode(b[8],b[9],b[10],b[11]) === 'WEBP') return true;
          if (b.length >= 2 && b[0] === 0x42 && b[1] === 0x4D) return true;
          if (b.length >= 4) {
            const s4 = String.fromCharCode(b[0],b[1],b[2],b[3]);
            if (s4 === 'II*\u0000' || s4 === 'MM\u0000*') return true;
          }
          return false;
        } catch { return false; }
      }
      async function sniffVideo(file) {
        try {
          const b = await readHead(file, 64);
          if (b.length >= 8 && String.fromCharCode(b[4],b[5],b[6],b[7]) === 'ftyp') return true;
          const s = String.fromCharCode(...b);
          if (s.toLowerCase().includes('webm')) return true;
          if (b.length >= 12 && String.fromCharCode(b[0],b[1],b[2],b[3]) === 'RIFF' && String.fromCharCode(b[8],b[9],b[10],b[11]) === 'AVI ') return true;
          return false;
        } catch { return false; }
      }
      function capturePosterFromVideoElement(video) {
        return new Promise((resolve, reject) => {
          const cap = () => {
            try {
              const vw = video.videoWidth || 320;
              const vh = video.videoHeight || 240;
              const maxW = 800;
              const r = vw > maxW ? maxW / vw : 1;
              const cw = Math.max(1, Math.round(vw * r));
              const ch = Math.max(1, Math.round(vh * r));
              const canvas = document.createElement('canvas');
              canvas.width = cw;
              canvas.height = ch;
              const ctx = canvas.getContext('2d');
              ctx.drawImage(video, 0, 0, cw, ch);
              canvas.toBlob((blob) => {
                if (blob) {
                  resolve(URL.createObjectURL(blob));
                } else {
                  resolve(canvas.toDataURL('image/jpeg', 0.82));
                }
              }, 'image/jpeg', 0.82);
            } catch (e) { reject(e); }
          };
          let t = 0.2;
          try {
            if (isFinite(video.duration) && !isNaN(video.duration) && video.duration > 0.2) {
              t = Math.min(0.2, video.duration / 20);
            }
          } catch {}
          const onSeeked = () => { video.removeEventListener('seeked', onSeeked); cap(); };
          const onLoaded = () => { video.removeEventListener('loadeddata', onLoaded); cap(); };
          video.addEventListener('seeked', onSeeked, { once: true });
          video.addEventListener('loadeddata', onLoaded, { once: true });
          try { video.currentTime = t; } catch {}
        });
      }
      async function validateFile(file, mode) {
        if (!file) return { ok: false, msg: 'No file provided' };
        const ext = extOf(file.name);
        if (mode === 'image') {
          if (!ALLOWED_IMAGE_TYPES.includes(file.type)) return { ok: false, msg: 'Unsupported image type' };
          if (!ALLOWED_IMAGE_EXT.includes(ext)) return { ok: false, msg: 'Unsupported image extension' };
          if (file.size > 10 * 1024 * 1024) return { ok: false, msg: 'File too large (max 10MB)' };
          const ok = await sniffImage(file);
          if (!ok) return { ok: false, msg: 'Invalid or corrupted image' };
          return { ok: true };
        } else {
          if (!ALLOWED_VIDEO_TYPES.includes(file.type)) return { ok: false, msg: 'Unsupported video type' };
          if (!ALLOWED_VIDEO_EXT.includes(ext)) return { ok: false, msg: 'Unsupported video extension' };
          if (file.size > 200 * 1024 * 1024) return { ok: false, msg: 'Video too large (max 200MB)' };
          const ok = await sniffVideo(file);
          if (!ok) return { ok: false, msg: 'Invalid or corrupted video' };
          return { ok: true };
        }
      }

      function applyTheme(t) {
        if (!t) return;
        const isDark = t === 'dark';
        const next = isDark ? 'dark' : 'light';
        if (window.__lastTheme === next) return;
        try { document.body.classList.remove('dark'); } catch {}
        document.documentElement.classList.toggle('dark', isDark);
        document.documentElement.setAttribute('data-theme', next);
        if (themeIcon) themeIcon.textContent = isDark ? 'dark_mode' : 'light_mode';
        window.__lastTheme = next;
      }
      function initTheme() {
        if (window.__themeInitDone) return;
        window.__themeInitDone = true;
        try {
          const saved = localStorage.getItem('theme');
          let mode = saved;
          if (!mode) {
            try {
              mode = (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) ? 'dark' : 'light';
            } catch { mode = 'light'; }
          }
          applyTheme(mode || 'light');
        } catch {
          applyTheme('light');
        }
      }
      if (window.matchMedia) {
        const mm = window.matchMedia('(prefers-color-scheme: dark)');
        mm.addEventListener('change', (e) => {
          const saved = localStorage.getItem('theme');
          if (!saved) applyTheme(e.matches ? 'dark' : 'light');
        });
      }
      themeBtn.addEventListener('click', () => {
        const next = document.documentElement.classList.contains('dark') ? 'light' : 'dark';
        localStorage.setItem('theme', next);
        applyTheme(next);
        themeIcon.classList.remove('sun-toggle-anim','moon-toggle-anim');
        void themeIcon.offsetWidth;
        themeIcon.classList.add(next === 'dark' ? 'moon-toggle-anim' : 'sun-toggle-anim');
        themeBtn.classList.add('theme-ripple');
        setTimeout(() => themeBtn.classList.remove('theme-ripple'), 420);
      });
      if (homeHeaderLink) {
        try {
          homeHeaderLink.addEventListener('click', (e) => {
            e.preventDefault();
            if (busy) {
              toast('Processing in progress. Refresh is disabled until it finishes.', 'info', 3000);
              return;
            }
            if (resultBlobUrl && downloadBtn && !downloadBtn.hasAttribute('disabled')) {
          const proceed = window.confirm('A result is ready. Refreshing will clear it. Continue?');
              if (!proceed) return;
              try { URL.revokeObjectURL(resultBlobUrl); } catch {}
              resultBlobUrl = null;
              setDownloadEnabled(false);
            }
            try { window.location.reload(); } catch { window.location.href = window.location.href; }
          });
        } catch {}
      }
      initTheme();
      function bindUploadControls() {
        const input = document.getElementById('fileInput');
        const vinput = document.getElementById('videoInput');
        if (dropArea) {
          if (dropClickHandler) {
            try { dropArea.removeEventListener('click', dropClickHandler); } catch {}
          }
          dropClickHandler = () => {
            if (busy) { toast('Uploads are disabled while processing', 'info', 2500); return; }
            if (source === 'image') {
              if (input) input.click();
            } else {
              if (vinput) vinput.click();
            }
          };
          dropArea.addEventListener('click', dropClickHandler);
        }
        if (input) input.onchange = (e) => {
          if (busy) { try { e.target.value = ''; } catch {} toast('Uploads are disabled while processing', 'info', 2500); return; }
          handleFiles(e.target.files);
        };
        if (vinput) vinput.onchange = (e) => {
          if (busy) { try { e.target.value = ''; } catch {} toast('Uploads are disabled while processing', 'info', 2500); return; }
          handleFiles(e.target.files);
        };
        if (dropArea) {
          const onDrag = (ev) => { ev.preventDefault(); ev.stopPropagation(); if (busy) return; dropArea.classList.add('drop-active'); };
          dropArea.addEventListener('dragenter', onDrag);
          dropArea.addEventListener('dragover', onDrag);
          dropArea.addEventListener('dragleave', (ev) => { ev.preventDefault(); ev.stopPropagation(); dropArea.classList.remove('drop-active'); });
          dropArea.addEventListener('drop', async (ev) => {
            ev.preventDefault();
            ev.stopPropagation();
            dropArea.classList.remove('drop-active');
            const dt = ev.dataTransfer;
            if (!dt || !dt.files || !dt.files.length) return;
            if (busy) { toast('Uploads are disabled while processing', 'info', 2500); return; }
            await handleFiles(dt.files);
          });
        }
      }
      bindUploadControls();
      setAnonymizeEnabled(false, false);

      function logMsg(msg, level = 'info') {}
      /* window.addEventListener('error', (e) => logMsg(e.message, 'error'));
      window.addEventListener('unhandledrejection', (e) => logMsg(String(e.reason), 'error'));
      if (copyLogsBtn) copyLogsBtn.addEventListener('click', async () => {});
      if (clearLogsBtn) clearLogsBtn.addEventListener('click', () => {}); */

      ;['dragenter', 'dragover', 'dragleave'].forEach(eventName => {
        if (dropArea) {
          dropArea.addEventListener(eventName, (e) => e.preventDefault());
          dropArea.addEventListener(eventName, (e) => e.stopPropagation());
        }
      });
      function positionTabIndicator(btn) {
        if (!btn) return;
        const container = btn.closest('#mobileSourceTabs') || btn.closest('#sourceTabs');
        const indicator = container && container.id === 'mobileSourceTabs' ? tabIndicatorMobile : tabIndicator;
        if (!indicator || !container) return;
        // Use offset metrics to avoid layout shifts and account for container padding consistently
        const inset = 2; // uniform inset to prevent the pill from touching button edges
        const left = Math.round(btn.offsetLeft) + inset;
        const top = Math.round(btn.offsetTop) + inset;
        const width = Math.max(0, Math.round(btn.offsetWidth) - inset * 2);
        const height = Math.max(0, Math.round(btn.offsetHeight) - inset * 2);
        // During initial layout (indicator-init), apply styles synchronously to avoid slide-in animation
        if (container.classList && container.classList.contains('indicator-init')) {
          indicator.style.left = `${left}px`;
          indicator.style.top = `${top}px`;
          indicator.style.width = `${width}px`;
          indicator.style.height = `${height}px`;
        } else {
          requestAnimationFrame(() => {
            indicator.style.left = `${left}px`;
            indicator.style.top = `${top}px`;
            indicator.style.width = `${width}px`;
            indicator.style.height = `${height}px`;
          });
        }
      }
      function recalcTabIndicators() {
        try {
          positionTabIndicator(source === 'image' ? tabImage : tabVideo);
          const mobileVisible =
            mobileSourceTabs &&
            window.matchMedia('(max-width: 640px)').matches &&
            getComputedStyle(mobileSourceTabs).display !== 'none';
          if (mobileVisible && tabImageMobile && tabVideoMobile) {
            positionTabIndicator(source === 'image' ? tabImageMobile : tabVideoMobile);
          }
          // After first layout, enable animations
          if (sourceTabs && sourceTabs.classList.contains('indicator-init')) {
            sourceTabs.classList.remove('indicator-init');
          }
          if (mobileSourceTabs && mobileSourceTabs.classList.contains('indicator-init')) {
            mobileSourceTabs.classList.remove('indicator-init');
          }
        } catch {}
      }
      function updateMetrics({ faces = null, ms = null, type = '', status = '' }) {
        if (metricFaces()) metricFaces().textContent = faces === null ? '—' : String(faces);
        if (metricTime()) metricTime().textContent = ms === null ? '—' : `${Math.round(ms)} ms`;
        if (metricType()) metricType().textContent = type ? type.replace('_',' ') : '—';
        if (metricStatus()) metricStatus().textContent = status || '—';
      }
      function setSource(next) {
        if (busy) {
          processingToast = toast('Processing in progress — switching tabs disabled until completion.', 'info', 0, true);
          return;
        }
        if (resultBlobUrl && downloadBtn && !downloadBtn.hasAttribute('disabled')) {
          const proceed = window.confirm('A result is ready to download. Switching tabs will clear it. Continue?');
          if (!proceed) return;
          try { URL.revokeObjectURL(resultBlobUrl); } catch {}
          resultBlobUrl = null;
          setDownloadEnabled(false);
        }
        // abort any in-flight processing and reset timers
        if (reprocTimer) { clearTimeout(reprocTimer); reprocTimer = null; }
        if (currentAbortController) { try { currentAbortController.abort(); } catch {} currentAbortController = null; }
        if (progressTimer) { try { clearInterval(progressTimer); } catch {} progressTimer = null; }
        busy = false;
        
        // clear selected data
        selectedFile = null;
        // switch source and rebuild UI
        source = next;
        const imgActive = next === 'image';
        const vidActive = next === 'video';
        dropArea.innerHTML = imgActive ? renderDropAreaContent() : renderVideoPlaceholderContent();
        bindUploadControls();
        tabImage.className = imgActive
          ? 'px-6 h-10 rounded-full font-bold text-sm leading-none text-on-primary relative z-10 transition-colors flex items-center'
          : 'px-6 h-10 rounded-full font-bold text-sm leading-none text-slate-700 dark:text-slate-300 relative z-10 transition-colors flex items-center';
        tabVideo.className = vidActive
          ? 'px-6 h-10 rounded-full font-bold text-sm leading-none text-on-primary relative z-10 transition-colors flex items-center'
          : 'px-6 h-10 rounded-full font-bold text-sm leading-none text-slate-700 dark:text-slate-300 relative z-10 transition-colors flex items-center';
        positionTabIndicator(imgActive ? tabImage : tabVideo);
        if (tabImageMobile && tabVideoMobile) {
          tabImageMobile.className = imgActive
            ? 'px-6 h-10 rounded-full font-bold text-sm leading-none text-on-primary relative z-10 transition-colors flex items-center'
            : 'px-6 h-10 rounded-full font-bold text-sm leading-none text-slate-700 dark:text-slate-300 relative z-10 transition-colors flex items-center';
          tabVideoMobile.className = vidActive
            ? 'px-6 h-10 rounded-full font-bold text-sm leading-none text-on-primary relative z-10 transition-colors flex items-center'
            : 'px-6 h-10 rounded-full font-bold text-sm leading-none text-slate-700 dark:text-slate-300 relative z-10 transition-colors flex items-center';
          positionTabIndicator(imgActive ? tabImageMobile : tabVideoMobile);
        }
        statusText.textContent = 'No file uploaded yet';
        if (inputHeading) {
          inputHeading.textContent = imgActive ? 'Original Image' : 'Original Video';
        }
        if (imgActive) {
          resultBox.innerHTML = `<div class="upload-circle bg-slate-200 text-slate-600 flex items-center justify-center transition-transform"><span class="material-symbols-outlined text-5xl">visibility_off</span></div><p class="text-xs px-12 text-slate-500">Your anonymized image will appear here</p>`;
        } else {
          resultBox.innerHTML = `<div class="upload-circle bg-slate-200 text-slate-600 flex items-center justify-center transition-transform"><span class="material-symbols-outlined text-5xl">visibility_off</span></div><p class="text-xs px-12 text-slate-500">Your anonymized video will appear here</p>`;
        }
        // keep previous downloadable result until next anonymize
        setAnonymizeEnabled(false, false);
        updateMetrics({ faces: null, ms: null, type: '', status: '' });
      }
      // Prevent initial jump: disable indicator transitions until first layout pass
      if (sourceTabs) sourceTabs.classList.add('indicator-init');
      if (mobileSourceTabs) mobileSourceTabs.classList.add('indicator-init');
      setSource('image');
      tabImage.addEventListener('click', () => setSource('image'));
      tabVideo.addEventListener('click', () => setSource('video'));
      if (tabImageMobile) tabImageMobile.addEventListener('click', () => setSource('image'));
      if (tabVideoMobile) tabVideoMobile.addEventListener('click', () => setSource('video'));
      window.addEventListener('resize', () => setTimeout(recalcTabIndicators, 0));
      window.addEventListener('orientationchange', () => setTimeout(recalcTabIndicators, 0));
      window.addEventListener('load', () => {
        // Position immediately, then once more after layout settles
        setTimeout(recalcTabIndicators, 0);
        setTimeout(recalcTabIndicators, 180);
      });
      document.addEventListener('click', (e) => {
        const btn = e.target.closest('button');
        if (btn) { try { btn.blur(); } catch {} }
      });
      function applyFullscreenClass() {
        try {
          const isMobile = window.matchMedia('(max-width: 640px)').matches;
          const isFS = !!document.fullscreenElement || ((window.innerHeight >= (screen.height - 1)) && (window.innerWidth >= (screen.width - 1)));
          document.body.classList.toggle('fullscreen', !isMobile && isFS);
        } catch {}
      }
      document.addEventListener('fullscreenchange', applyFullscreenClass);
      window.addEventListener('resize', applyFullscreenClass);
      applyFullscreenClass();
      const STATIC_BASE = (function() {
        try {
          const host = String(location.hostname || '');
          return host.endsWith('github.io') ? '' : '/web';
        } catch { return '/web'; }
      })();
      const API_BASE = (function() {
        try {
          const v = localStorage.getItem('api_base') || '';
          return v ? v.replace(/\/+$/,'') : '';
        } catch { return ''; }
      })();
      function warmUpApi() {
        try {
          if (!API_BASE) return;
          fetch(`${API_BASE}/api/ping`, { method: 'GET', cache: 'no-store', mode: 'cors', keepalive: true }).catch(() => {});
          setTimeout(() => { fetch(`${API_BASE}/`, { method: 'HEAD', cache: 'no-store', mode: 'cors' }).catch(() => {}); }, 20);
        } catch {}
      }
      window.addEventListener('load', () => { setTimeout(warmUpApi, 0); });
      document.addEventListener('visibilitychange', () => { if (document.visibilityState === 'visible') warmUpApi(); });
      (function ensureLogo() {
        const img = document.getElementById('headerLogo');
        const container = document.getElementById('logoContainer');
        if (!img || !container) return;
        img.addEventListener('error', () => {
          img.onerror = null;
          container.innerHTML = '<span class="material-symbols-outlined text-primary">face_retouching_off</span>';
        });
      })();
      (function ensureAnonymizeIcon() {
        const icon = document.getElementById('anonymizeIcon');
        if (!icon) return;
        icon.addEventListener('error', () => {
          try {
            const btn = document.getElementById('anonymizeBtn');
            if (btn) btn.innerHTML = `<span class="material-symbols-outlined text-[32px]">visibility_off</span> Anonymize`;
          } catch {}
        });
        try {
          const base = `${STATIC_BASE}/anonymizer%20button%20icon.png`;
          icon.src = `${base}?v=${Date.now()}`;
        } catch {}
      })();
      async function refreshLogo() {
        const img = document.getElementById('headerLogo');
        if (!img) return;
        const base = `${STATIC_BASE}/logo.png`;
        const v = Date.now();
        img.src = `${base}?v=${v}`;
      }
      refreshLogo();
      (function fixFavicon() {
        try {
          const ts = Date.now();
          const icon = document.querySelector('link[rel="icon"]#favicon');
          if (icon) icon.href = `/favicon.png?size=32&t=${ts}`;
          const shortcut = document.querySelector('link[rel="shortcut icon"]');
          if (shortcut) shortcut.href = `/favicon.png?size=32&t=${ts}`;
          const apple = document.querySelector('link[rel="apple-touch-icon"]');
          if (apple) apple.href = `/favicon.png?size=180&t=${ts}`;
        } catch {}
      })();

      let intensityRaf = 0;
      const scheduleIntensityUpdate = (updateStatus = false) => {
        if (intensityRaf) return;
        intensityRaf = requestAnimationFrame(() => {
          intensityRaf = 0;
          updateIntensityUI();
          if (updateStatus) {
            const _ = String(intensityRange.value);
          }
        });
      };
      intensityRange.addEventListener('input', () => {
        scheduleIntensityUpdate(true);
      }, { passive: true });
      intensityRange.addEventListener('change', () => {
        scheduleIntensityUpdate(true);
      });
      function updateIntensityUI() {
        const v = Number(intensityRange.value);
        intensityLabel.textContent = v + '%';
        const min = Number(intensityRange.min || 0);
        const max = Number(intensityRange.max || 100);
        const ratio = Math.max(0, Math.min(1, (v - min) / (max - min)));
        const width = Math.max(0, intensityRange.clientWidth || intensityRange.offsetWidth || 0);
        const x = Math.round(ratio * width);
        const styles = getComputedStyle(document.documentElement);
        const pri = (styles.getPropertyValue('--text-primary') || '').trim() || (document.documentElement.classList.contains('dark') ? '#EDEDED' : '#0F0F10');
        const base = (styles.getPropertyValue('--surface-border') || '').trim() || (document.documentElement.classList.contains('dark') ? '#262626' : '#E1E1E4');
        intensityRange.style.background = `linear-gradient(to right, ${pri} ${x}px, ${base} ${x}px)`;
      }
      const typeSelectWrapper = document.getElementById('typeSelectWrapper');
      const typeSelectBtn = document.getElementById('typeSelectBtn');
      const typeSelectText = document.getElementById('typeSelectText');
      const typeMenu = document.getElementById('typeMenu');
      const TYPE_LABELS = { blur: 'Gaussian Blur', pixelate: 'Pixelation Grid', black_bar: 'Censored Black Bar' };
      typeSelect.addEventListener('change', () => {
        const _ = TYPE_LABELS[typeSelect.value] || typeSelect.value;
      });
      if (typeSelectWrapper && typeSelectBtn && typeMenu && typeSelectText && typeSelect) {
        const closeMenu = () => { typeSelectWrapper.classList.remove('select-open'); typeSelectBtn.setAttribute('aria-expanded','false'); };
        const openMenu = () => { typeSelectWrapper.classList.add('select-open'); typeSelectBtn.setAttribute('aria-expanded','true'); };
        // Fix Type button width to longest option so it never resizes on selection
        (function fixTypeSelectWidthToLongest(){
          try {
            const liNodes = Array.from(typeMenu.querySelectorAll('li'));
            if (!liNodes.length) return;
            const clone = typeSelectBtn.cloneNode(true);
            clone.style.position = 'absolute';
            clone.style.visibility = 'hidden';
            clone.style.pointerEvents = 'none';
            clone.style.left = '-99999px';
            clone.style.top = '-99999px';
            document.body.appendChild(clone);
            let maxW = Math.round(typeSelectBtn.offsetWidth);
            const textNode = clone.querySelector('#typeSelectText');
            liNodes.forEach(li => {
              if (textNode) textNode.textContent = (li.textContent || '').trim();
              maxW = Math.max(maxW, Math.round(clone.offsetWidth));
            });
            clone.remove();
            if (maxW > 0) typeSelectBtn.style.minWidth = maxW + 'px';
          } catch {}
        })();
        typeSelectBtn.addEventListener('click', () => {
          if (typeSelectWrapper.classList.contains('select-open')) closeMenu(); else openMenu();
        });
        document.addEventListener('mousedown', (e) => { if (!typeSelectWrapper.contains(e.target)) closeMenu(); });
        document.addEventListener('touchstart', (e) => { if (!typeSelectWrapper.contains(e.target)) closeMenu(); }, { passive: true });
        document.addEventListener('pointerdown', (e) => { if (!typeSelectWrapper.contains(e.target)) closeMenu(); });
        document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeMenu(); });
        typeMenu.querySelectorAll('li').forEach(li => {
          li.addEventListener('click', () => {
            const val = li.getAttribute('data-value');
            typeSelect.value = val;
            typeSelectText.textContent = TYPE_LABELS[val] || val;
            typeSelect.dispatchEvent(new Event('change'));
            closeMenu();
          });
          li.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              li.click();
            }
          });
        });
      }
      updateIntensityUI();
      window.addEventListener('resize', updateIntensityUI);
      if (themeBtn) {
        themeBtn.addEventListener('click', () => {
          setTimeout(updateIntensityUI, 0);
        });
      }

      (function aspectRatioFallback() {
        try {
          if (CSS && CSS.supports && CSS.supports('aspect-ratio', '1 / 1')) return;
        } catch {}
        const apply = () => {
          try {
            const boxes = document.querySelectorAll('.img-box');
            boxes.forEach((box) => {
              const w = box.clientWidth || box.offsetWidth || 0;
              if (w > 0) {
                const h = Math.round(w * 9 / 16);
                box.style.height = h + 'px';
              }
            });
          } catch {}
        };
        apply();
        window.addEventListener('resize', apply);
        window.addEventListener('orientationchange', apply);
        document.addEventListener('readystatechange', () => { if (document.readyState === 'complete') apply(); });
      })();

      clearBtn.addEventListener('click', () => {
        try {
          const icon = clearBtn.querySelector('.material-symbols-outlined');
          if (icon) {
            icon.classList.remove('spin-once');
            void icon.offsetWidth;
            icon.classList.add('spin-once');
          }
        } catch {}
        const f = document.getElementById('fastModeToggle');
        const isDefault =
          selectedFile === null &&
          resultBlobUrl === null &&
          !busy &&
          currentAbortController === null &&
          statusText && statusText.textContent === 'No file uploaded yet' &&
          typeSelect && typeSelect.value === 'blur' &&
          intensityRange && String(intensityRange.value) === '40' &&
          (!f || f.checked === false);
        if (isDefault) {
          return;
        }
        selectedFile = null;
        if (reprocTimer) { clearTimeout(reprocTimer); reprocTimer = null; }
        if (currentAbortController) { try { currentAbortController.abort(); } catch {} currentAbortController = null; }
        if (progressTimer) { try { clearInterval(progressTimer); } catch {} progressTimer = null; }
        if (processingAnimTimer) { try { clearInterval(processingAnimTimer); } catch {} processingAnimTimer = null; }
        processingAnimStep = 0;
        busy = false;
        setTabsInteractivity(true);
        if (processingToast && typeof processingToast.remove === 'function') { try { processingToast.remove(); } catch {} processingToast = null; }
        // reset button visuals first, then disable until next upload
        setAnonymizeEnabled(true, false);
        dropArea.innerHTML = source === 'image' ? renderDropAreaContent() : renderVideoPlaceholderContent();
        bindUploadControls();
        if (source === 'image') {
          resultBox.innerHTML = `<div class="upload-circle bg-slate-200 text-slate-600 flex items-center justify-center transition-transform"><span class="material-symbols-outlined text-4xl">visibility_off</span></div><p class="text-xs px-12 text-slate-500">Your anonymized image will appear here</p>`;
        } else {
          resultBox.innerHTML = `<div class="upload-circle bg-slate-200 text-slate-600 flex items-center justify-center transition-transform"><span class="material-symbols-outlined text-4xl">visibility_off</span></div><p class="text-xs px-12 text-slate-500">Your anonymized video will appear here</p>`;
        }
        statusText.textContent = 'No file uploaded yet';
        
        setDownloadEnabled(false);
        setAnonymizeEnabled(false, false);
        updateMetrics({ faces: null, ms: null, type: '', status: '' });
        // reset controls
        if (typeSelect && typeSelectText) {
          typeSelect.value = 'blur';
          typeSelectText.textContent = 'Gaussian Blur';
        }
        if (intensityRange && intensityLabel) {
          intensityRange.value = 40;
          intensityLabel.textContent = '40%';
          updateIntensityUI();
        }
        try {
          const f = document.getElementById('fastModeToggle');
          if (f) f.checked = false;
        } catch {}
        if (resultBlobUrl) { URL.revokeObjectURL(resultBlobUrl); resultBlobUrl = null; }
        try { if (selectedVideoPosterUrl) { URL.revokeObjectURL(selectedVideoPosterUrl); selectedVideoPosterUrl = null; } } catch {}
        toast('Cleared successfully', 'success', 2400);
      });

      anonymizeBtn.addEventListener('click', () => source === 'image' ? runAnonymize() : runAnonymizeVideo());
      async function runAnonymize() {
        if (busy) return;
        if (!selectedFile) { toast('Please upload an image first', 'warning', 2000); return; }
        // Clear any previous downloadable result when starting a new run, even with same file
        if (resultBlobUrl) {
          try { URL.revokeObjectURL(resultBlobUrl); } catch {}
          resultBlobUrl = null;
          setDownloadEnabled(false);
        }
        let start = 0;
        let success = false;
        let slowTimer = null;
        let networkTimer = null;
        try {
          busy = true;
          setAnonymizeEnabled(false, true);
          startChecking('image');
          // server-side validation for faces to avoid showing progress on errors
          const vfd = new FormData();
          vfd.append('image', selectedFile);
          const vresp = await fetch(`${API_BASE}/api/validate_image`, { method: 'POST', body: vfd });
          if (!vresp.ok) {
            try { startChecking('image'); } catch {}
            setTimeout(() => { try { clearRejectedUpload('No faces detected, or the image is invalid'); } catch {} }, 800);
            busy = false;
            try { setTabsInteractivity(true); } catch {}
            try { setAnonymizeEnabled(true, false); } catch {}
            try { setSettingsEnabled(true); } catch {}
            return;
          }
          const vj = await vresp.json();
          if (!vj.ok || Number(vj.faces || 0) <= 0) {
            try { startChecking('image'); } catch {}
            setTimeout(() => { try { clearRejectedUpload('No faces found'); } catch {} }, 800);
            busy = false;
            try { setTabsInteractivity(true); } catch {}
            try { setAnonymizeEnabled(true, false); } catch {}
            try { setSettingsEnabled(true); } catch {}
            return;
          }
          start = performance.now();
          const snapType = String(typeSelect.value);
          const snapIntensity = String(intensityRange.value);
          slowTimer = setTimeout(() => {
            try {
              const f = document.getElementById('fastModeToggle');
              if (busy && (!f || !f.checked)) {
                toast("This is taking longer than usual. Cancel and enable Fast Mode for faster results (lower quality).", 'info', 8000);
              }
            } catch {}
          }, 60000);
          const fd = new FormData();
          fd.append('image', selectedFile);
          fd.append('type', snapType);
          fd.append('intensity', snapIntensity);
          currentAbortController = new AbortController();
          networkTimer = setTimeout(() => {
            try { if (currentAbortController) currentAbortController.abort(); } catch {}
          }, 120000);
          const blob = await new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            xhr.open('POST', `${API_BASE}/api/anonymize`);
            xhr.responseType = 'blob';
            if (currentAbortController && currentAbortController.signal) {
              currentAbortController.signal.addEventListener('abort', () => { try { xhr.abort(); } catch {} });
            }
            xhr.onerror = () => reject(new Error('Network error during upload'));
            xhr.ontimeout = () => reject(new Error('Upload timed out'));
            xhr.onload = () => {
              if (xhr.status >= 200 && xhr.status < 300) {
                beginProcessingProgress('image');
                resolve(xhr.response);
              } else {
                const ct = (xhr.getResponseHeader('Content-Type') || '').toLowerCase();
                const blob = xhr.response;
                if (blob && ct.includes('application/json')) {
                  try {
                    const fr = new FileReader();
                    fr.onload = () => {
                      try {
                        const txt = fr.result || '';
                        const j = JSON.parse(String(txt || ''));
                        const msg = j && j.error ? j.error : 'Image processing failed';
                        reject(new Error(msg));
                      } catch {
                        reject(new Error('Image processing failed'));
                      }
                    };
                    fr.onerror = () => reject(new Error('Image processing failed'));
                    fr.readAsText(blob);
                    return;
                  } catch {
                    // fallthrough
                  }
                }
                reject(new Error('Image processing failed'));
              }
            };
            xhr.send(fd);
          });
          if (resultBlobUrl) { URL.revokeObjectURL(resultBlobUrl); }
          resultBlobUrl = URL.createObjectURL(blob);
          success = true;
        } catch (err) {
          if (err && err.name === 'AbortError') {
            // cancelled
          } else {
            const emsg = (err && err.message ? String(err.message).toLowerCase() : '');
            if (emsg.includes('no face')) {
              clearRejectedUpload('No faces found');
            } else {
              logMsg(err && (err.stack || err.message) ? (err.stack || err.message) : String(err), 'error');
              try { startChecking('image'); } catch {}
              setTimeout(() => { try { clearRejectedUpload('Processing failed'); } catch {} }, 600);
            }
          }
        } finally {
          if (slowTimer) { clearTimeout(slowTimer); slowTimer = null; }
          if (networkTimer) { clearTimeout(networkTimer); networkTimer = null; }
          currentAbortController = null;
          const end = performance.now();
          const diff = MIN_PROCESS_MS - (end - start);
          if (diff > 0) { await new Promise(r => setTimeout(r, diff)); }
          if (success && resultBlobUrl) {
            finishProgress();
            await new Promise(r => setTimeout(r, 300));
          resultBox.innerHTML = `<img class="bg-blur" src="${resultBlobUrl}" alt="" decoding="async"><img class="img-main" src="${resultBlobUrl}" alt="Anonymized result preview" decoding="async" style="cursor: pointer;">`;
            try {
              const imgEl = resultBox.querySelector('.img-main');
              if (imgEl) {
                imgEl.addEventListener('click', () => {
                  try { openPreviewOverlayForImage(resultBlobUrl); } catch {}
                });
              }
            } catch {}
            setDownloadEnabled(true);
            toast('Anonymized image ready', 'success', 2000);
          }
          busy = false;
          setAnonymizeEnabled(true, false);
          setSettingsEnabled(true);
        }
      }
      async function runAnonymizeVideo() {
        if (busy) return;
        if (!selectedFile) { toast('Please select a video first', 'warning', 2000); return; }
        // Clear any previous downloadable result when starting a new run, even with same file
        if (resultBlobUrl) {
          try { URL.revokeObjectURL(resultBlobUrl); } catch {}
          resultBlobUrl = null;
          setDownloadEnabled(false);
        }
        let start = 0;
        let success = false;
        let slowTimer = null;
        let jobPollTimer = null;
        let jobId = null;
        let networkTimer = null;
        try {
          busy = true;
          setAnonymizeEnabled(false, true);
          startChecking('video');
          start = performance.now();
          try {
            const vfd = new FormData();
            vfd.append('video', selectedFile);
            const vresp = await fetch(`${API_BASE}/api/validate_video`, { method: 'POST', body: vfd });
            if (!vresp.ok) {
              throw new Error('Video validation failed');
            }
            const vj = await vresp.json();
            if (!vj || vj.faces === undefined || Number(vj.faces || 0) <= 0) {
              throw new Error('No faces found');
            }
          } catch (e) {
            try { startChecking('video'); } catch {}
            setTimeout(() => {
              try { clearRejectedUpload(e && e.message ? e.message : 'Video validation failed'); } catch {}
            }, 800);
            busy = false;
            try { setTabsInteractivity(true); } catch {}
            try { setAnonymizeEnabled(true, false); } catch {}
            try { setSettingsEnabled(true); } catch {}
            return;
          }
          const snapType = String(typeSelect.value);
          const snapIntensity = String(intensityRange.value);
          let snapFast = '0';
          try {
            const f = document.getElementById('fastModeToggle');
            snapFast = f && f.checked ? '1' : '0';
          } catch {}
          const fd = new FormData();
          fd.append('video', selectedFile);
          fd.append('type', snapType);
          fd.append('intensity', snapIntensity);
          fd.append('fast_mode', snapFast);
          currentAbortController = new AbortController();
          networkTimer = setTimeout(() => {
            try { if (currentAbortController) currentAbortController.abort(); } catch {}
          }, 120000);
          startUploadProgress('video');
          const j = await new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            xhr.open('POST', `${API_BASE}/api/start_job_video`);
            xhr.responseType = 'json';
            if (currentAbortController && currentAbortController.signal) {
              currentAbortController.signal.addEventListener('abort', () => { try { xhr.abort(); } catch {} });
            }
            xhr.upload.onprogress = (e) => {
              if (e && e.lengthComputable) {
                const pct = Math.max(0, Math.min(100, (e.loaded / e.total) * 100));
                setProgressBar(pct, 'Uploading video');
                lastProgressDisplay = Math.max(lastProgressDisplay || 0, pct);
              }
            };
            xhr.upload.onloadend = () => {
              const lbl = document.getElementById('progressLabel');
              if (lbl) lbl.textContent = 'Processing video';
              // Reset progress for processing phase so we don't carry over 100% from upload
              progressKind = 'video';
              progressPhase = '';
              progressValue = 0;
              lastProgressDisplay = 0;
              const pctEl = document.getElementById('progressPercent');
              const barEl = document.getElementById('progressBarInner');
              const stripeEl = document.getElementById('progressStripe');
              if (pctEl) {
                pctEl.removeAttribute('data-finalizing');
                pctEl.textContent = '0%';
              }
              if (barEl) barEl.style.width = '0%';
              if (stripeEl) stripeEl.style.display = 'none';
              if (finalizeAnimTimer) { clearInterval(finalizeAnimTimer); finalizeAnimTimer = null; }
            };
            xhr.onerror = () => reject(new Error('Network error during upload'));
            xhr.ontimeout = () => reject(new Error('Upload timed out'));
            xhr.onload = () => {
              if (xhr.status >= 200 && xhr.status < 300) {
                resolve(xhr.response);
              } else {
                reject(new Error('Video processing failed to start'));
              }
            };
            xhr.send(fd);
          });
          jobId = j && j.id ? j.id : null;
          if (!jobId) throw new Error('Unable to start progress job');
          slowTimer = setTimeout(() => {
            try {
              const f = document.getElementById('fastModeToggle');
              if (busy && (!f || !f.checked)) {
                toast("If processing feels too slow, cancel and enable Fast Mode for quicker results (lower quality).", 'info', 8000);
              }
            } catch {}
          }, 60000);
          await new Promise((resolve, reject) => {
            jobPollTimer = setInterval(async () => {
              try {
                const pr = await fetch(`${API_BASE}/api/job_progress?id=${encodeURIComponent(jobId)}`);
                if (!pr.ok) return;
                const pj = await pr.json();
                if (!pj.ok) return;
                const bar = document.getElementById('progressBarInner');
                const pct = document.getElementById('progressPercent');
                const stripe = document.getElementById('progressStripe');
                const p = Number(pj.percent || 0);
                const next = Math.max(Number(progressValue || 0), p);
                progressValue = next;
                const disp = Math.max(lastProgressDisplay, next);
                lastProgressDisplay = disp;
                if (bar) bar.style.width = `${disp}%`;
                if (pct) {
                  if (disp >= 95 && !pj.done) {
                    if (!pct.getAttribute('data-finalizing')) {
                      pct.setAttribute('data-finalizing', '1');
                      pct.innerHTML = 'Finalizing<span id="finalDots"><span class="dot">.</span><span class="dot">.</span><span class="dot">.</span></span>';
                      finalizeAnimStep = 0;
                      try {
                        const dotsNow = document.querySelectorAll('#finalDots .dot');
                        if (dotsNow && dotsNow.length) {
                          dotsNow.forEach((d, i) => { d.style.visibility = i === 0 ? 'visible' : 'hidden'; });
                        }
                      } catch {}
                      if (!finalizeAnimTimer) {
                        finalizeAnimTimer = setInterval(() => {
                          const dots = document.querySelectorAll('#finalDots .dot');
                          if (!dots || dots.length === 0) return;
                          finalizeAnimStep = (finalizeAnimStep + 1) % 3;
                          dots.forEach((d, i) => { d.style.visibility = i <= finalizeAnimStep ? 'visible' : 'hidden'; });
                        }, 500);
                      }
                    }
                  } else {
                    if (finalizeAnimTimer) { clearInterval(finalizeAnimTimer); finalizeAnimTimer = null; }
                    if (pct.getAttribute('data-finalizing')) pct.removeAttribute('data-finalizing');
                    pct.textContent = `${Math.round(disp)}%`;
                  }
                }
                if (stripe) stripe.style.display = next >= 95 && !pj.done ? 'block' : 'none';
                try { if (progressKind === 'video') { updateProgressLabelByPercent('video', disp); } } catch {}
                if (pj.done) {
                  if (jobPollTimer) { clearInterval(jobPollTimer); jobPollTimer = null; }
                  if (pj.faces === 0) {
                    return reject(new Error('No faces found'));
                  }
                const dl = await fetch(`${API_BASE}/api/job_download?id=${encodeURIComponent(jobId)}`);
                if (!dl.ok) return reject(new Error('Download not ready'));
                const headerCt = dl.headers ? (dl.headers.get('Content-Type') || '') : '';
                const blob = await dl.blob();
                  if (resultBlobUrl) { URL.revokeObjectURL(resultBlobUrl); }
                  resultBlobUrl = URL.createObjectURL(blob);
                resultBlobMime = blob && blob.type ? blob.type : (headerCt || '');
                  success = true;
                  return resolve(true);
                }
              } catch (e) {
                // swallow transient errors
              }
            }, 400);
          });
        } catch (err) {
          if (err && err.name === 'AbortError') {
            // cancelled
          } else {
            const emsg = (err && err.message ? String(err.message).toLowerCase() : '');
            if (emsg.includes('no face')) {
              clearRejectedUpload('No faces found');
            } else {
              logMsg(err && (err.stack || err.message) ? (err.stack || err.message) : String(err), 'error');
              try { startChecking('video'); } catch {}
              setTimeout(() => { try { clearRejectedUpload('Processing failed'); } catch {} }, 600);
            }
          }
        } finally {
          if (slowTimer) { clearTimeout(slowTimer); slowTimer = null; }
          if (jobPollTimer) { clearInterval(jobPollTimer); jobPollTimer = null; }
           if (networkTimer) { clearTimeout(networkTimer); networkTimer = null; }
          currentAbortController = null;
          const end = performance.now();
          const diff = MIN_PROCESS_MS - (end - start);
          if (diff > 0) { await new Promise(r => setTimeout(r, diff)); }
          if (success && resultBlobUrl) {
            finishProgress();
            await new Promise(r => setTimeout(r, 300));
            const canPlay = (() => {
              try {
                const vt = document.createElement('video');
                return resultBlobMime ? vt.canPlayType(resultBlobMime) : '';
              } catch { return ''; }
            })();
            if (canPlay && canPlay.length) {
              resultBox.innerHTML = `<video class="img-main w-full h-full" controls preload="metadata" playsinline webkit-playsinline controlsList="nodownload noremoteplayback">
                <source src="${resultBlobUrl}" type="${resultBlobMime}">
              </video>`;
              const vid = resultBox.querySelector('video');
              if (vid) {
                try { vid.load(); } catch {}
                vid.addEventListener('error', () => {
                  toast('Unable to preview video (codec or format not supported)', 'error', 6000);
                  try {
                    resultBox.innerHTML = `<div class="text-center text-slate-600 dark:text-slate-300 text-sm">
                      Preview not supported by this browser.<br/>
                      <a class="underline text-primary" href="${resultBlobUrl}" download>Download the video</a> or <a class="underline text-primary" href="${resultBlobUrl}" target="_blank" rel="noopener">open in a new tab</a>.
                    </div>`;
                  } catch {}
                });
              }
            } else {
              resultBox.innerHTML = `<div class="text-center text-slate-600 dark:text-slate-300 text-sm">
                Preview not supported by this browser.<br/>
                <a class="underline text-primary" href="${resultBlobUrl}" download>Download the video</a> or <a class="underline text-primary" href="${resultBlobUrl}" target="_blank" rel="noopener">open in a new tab</a>.
              </div>`;
            }
            setDownloadEnabled(true);
            toast('Anonymized video ready', 'success', 2000);
          }
          busy = false;
          setAnonymizeEnabled(true, false);
          setSettingsEnabled(true);
        }
      }
      
      function scheduleAnonymize() {
        if (!selectedFile) return;
        if (reprocTimer) clearTimeout(reprocTimer);
        reprocTimer = setTimeout(() => runAnonymize(), 250);
      }
      function setSettingsEnabled(enabled) {
        try {
          if (typeSelectBtn) {
            if (enabled) {
              typeSelectBtn.removeAttribute('disabled');
              typeSelectBtn.style.pointerEvents = 'auto';
              typeSelectBtn.setAttribute('aria-expanded','false');
            } else {
              typeSelectBtn.setAttribute('disabled','');
              typeSelectBtn.style.pointerEvents = 'none';
              typeSelectBtn.setAttribute('aria-expanded','false');
              if (typeSelectWrapper) typeSelectWrapper.classList.remove('select-open');
            }
          }
          if (intensityRange) {
            if (enabled) {
              intensityRange.removeAttribute('disabled');
              intensityRange.style.pointerEvents = 'auto';
            } else {
              intensityRange.setAttribute('disabled','');
              intensityRange.style.pointerEvents = 'none';
            }
          }
          const fmt = document.getElementById('fastModeToggle');
          if (fmt) {
            if (enabled) {
              fmt.removeAttribute('disabled');
              fmt.style.pointerEvents = 'auto';
            } else {
              fmt.setAttribute('disabled','');
              fmt.style.pointerEvents = 'none';
            }
          }
        } catch {}
      }
      function setUploadEnabled(enabled) {
        try {
          const btn = document.getElementById('browseBtn');
          const input = document.getElementById('fileInput');
          const vbtn = document.getElementById('browseVideoBtn');
          const vinput = document.getElementById('videoInput');
          const area = document.getElementById('dropArea');
          [btn, vbtn].forEach(el => {
            if (!el) return;
            if (enabled) {
              el.removeAttribute('disabled');
              el.style.pointerEvents = 'auto';
              el.classList.remove('cursor-not-allowed','opacity-50');
            } else {
              el.setAttribute('disabled','');
              el.style.pointerEvents = 'none';
              el.classList.add('cursor-not-allowed','opacity-50');
            }
          });
          [input, vinput].forEach(el => {
            if (!el) return;
            if (enabled) {
              el.removeAttribute('disabled');
            } else {
              el.setAttribute('disabled','');
            }
          });
          if (area) {
            area.style.pointerEvents = enabled ? 'auto' : 'none';
            area.classList.toggle('cursor-not-allowed', !enabled);
            area.classList.toggle('opacity-60', !enabled);
          }
        } catch {}
      }
      function setAnonymizeEnabled(enabled, processing) {
        if (enabled) {
          anonymizeBtn.disabled = false;
          anonymizeBtn.setAttribute('aria-busy', 'false');
          anonymizeBtn.style.pointerEvents = 'auto';
          anonymizeBtn.classList.remove('cursor-not-allowed','opacity-50');
          anonymizeBtn.innerHTML = `<span id="anonymizeText" class="leading-none">Anonymize</span>`;
          if (processingAnimTimer) { clearInterval(processingAnimTimer); processingAnimTimer = null; }
          processingAnimStep = 0;
          setTabsInteractivity(true);
          setSettingsEnabled(true);
          setUploadEnabled(true);
          if (processingToast && typeof processingToast.remove === 'function') { try { processingToast.remove(); } catch {} processingToast = null; }
        } else {
          if (processing) {
            processingAnimStep = 0;
            anonymizeBtn.innerHTML = `<span class="leading-none">Processing <span id="procDots"><span class="dot">.</span><span class="dot">.</span><span class="dot">.</span></span></span>`;
            if (processingAnimTimer) { clearInterval(processingAnimTimer); }
            processingAnimTimer = setInterval(() => {
              processingAnimStep = (processingAnimStep + 1) % 3;
              const dots = anonymizeBtn.querySelectorAll('#procDots .dot');
              dots.forEach((d, i) => { d.style.visibility = i <= processingAnimStep ? 'visible' : 'hidden'; });
            }, 500);
            setTabsInteractivity(false);
            setSettingsEnabled(false);
            setUploadEnabled(false);
            processingToast = toast('Processing in progress — switching tabs and settings are disabled until completion.', 'info', 0, true);
          }
          anonymizeBtn.disabled = true;
          anonymizeBtn.setAttribute('aria-busy', 'true');
          anonymizeBtn.style.pointerEvents = 'none';
          anonymizeBtn.classList.add('cursor-not-allowed','opacity-50');
        }
      }

      

      function toast(msg, type = 'info', duration = 2000, noClose = false) {
        return showToast({ title: type === 'error' ? 'Error' : type === 'success' ? 'Success' : type === 'warning' ? 'Warning' : 'Info', message: msg, type, duration, noClose });
      }

      function clearRejectedUpload(message = '') {
        try { if (progressTimer) { clearInterval(progressTimer); } } catch {}
        try { if (finalizeAnimTimer) { clearInterval(finalizeAnimTimer); } } catch {}
        try { if (scanAnimTimer) { clearInterval(scanAnimTimer); } } catch {}
        progressKind = '';
        progressPhase = '';
        progressTimer = null;
        finalizeAnimTimer = null;
        scanAnimTimer = null;
        try {
          if (selectedPreviewUrl) { URL.revokeObjectURL(selectedPreviewUrl); selectedPreviewUrl = null; }
        } catch {}
        try {
          if (selectedVideoPosterUrl) { URL.revokeObjectURL(selectedVideoPosterUrl); selectedVideoPosterUrl = null; }
        } catch {}
        selectedFile = null;
        dropArea.innerHTML = source === 'image' ? renderDropAreaContent() : renderVideoPlaceholderContent();
        bindUploadControls();
        statusText.textContent = 'No file uploaded yet';
        if (source === 'image') {
          resultBox.innerHTML = `<div class="upload-circle bg-slate-200 text-slate-600 flex items-center justify-center transition-transform"><span class="material-symbols-outlined text-4xl">visibility_off</span></div><p class="text-xs px-12 text-slate-500">Your anonymized image will appear here</p>`;
        } else {
          resultBox.innerHTML = `<div class="upload-circle bg-slate-200 text-slate-600 flex items-center justify-center transition-transform"><span class="material-symbols-outlined text-4xl">visibility_off</span></div><p class="text-xs px-12 text-slate-500">Your anonymized video will appear here</p>`;
        }
        // keep previous downloadable result; only clear on anonymize
        setAnonymizeEnabled(false, false);
        const input = document.getElementById('fileInput');
        const vinput = document.getElementById('videoInput');
        try { if (input) input.value = ''; } catch {}
        try { if (vinput) vinput.value = ''; } catch {}
        const msg = message ? `Upload cleared — ${message}` : 'Upload cleared';
        toast(msg, 'warning', 6000);
      }

      function shortenMiddle(name, maxLen) {
        if (!name || name.length <= maxLen) return name;
        const idx = name.lastIndexOf('.');
        const ext = idx > 0 ? name.slice(idx) : '';
        const base = idx > 0 ? name.slice(0, idx) : name;
        const budget = Math.max(3, maxLen - ext.length - 1);
        const head = Math.ceil(budget / 2);
        const tail = Math.floor(budget / 2);
        return base.slice(0, head) + '…' + base.slice(-tail) + ext;
      }
      function formatFileNameForDisplay(name) {
        let maxLen = 48;
        const w = window.innerWidth || 1024;
        if (w <= 360) maxLen = 18;
        else if (w <= 480) maxLen = 24;
        else if (w <= 640) maxLen = 32;
        return shortenMiddle(name, maxLen);
      }
      function updateStatusTextForViewport() {
        if (selectedFile && statusText) {
          statusText.textContent = formatFileNameForDisplay(selectedFile.name || '');
        }
      }
      window.addEventListener('resize', () => { updateStatusTextForViewport(); }, { passive: true });

      async function handleFiles(files) {
        if (!files || !files.length) return;
        // keep previous downloadable result until user clicks anonymize again
        const f = files[0];
        const mode = source === 'image' ? 'image' : 'video';
        // Proactively clear any previous result to avoid stale previews (mobile caching quirks)
        if (resultBlobUrl) {
          try { URL.revokeObjectURL(resultBlobUrl); } catch {}
          resultBlobUrl = null;
          setDownloadEnabled(false);
          try {
            if (resultBox) {
              resultBox.innerHTML = mode === 'image'
                ? `<div class="upload-circle bg-slate-200 text-slate-600 flex items-center justify-center transition-transform"><span class="material-symbols-outlined text-5xl">visibility_off</span></div><p class="text-xs px-12 text-slate-500">Your anonymized image will appear here</p>`
                : `<div class="upload-circle bg-slate-200 text-slate-600 flex items-center justify-center transition-transform"><span class="material-symbols-outlined text-5xl">visibility_off</span></div><p class="text-xs px-12 text-slate-500">Your anonymized video will appear here</p>`;
            }
          } catch {}
        }
        const res = await validateFile(f, mode);
        if (!res.ok) {
          logMsg(res.msg, 'warn');
          clearRejectedUpload(res.msg || 'File rejected');
          return;
        }
        selectedFile = f;
        if (selectedPreviewUrl) { try { URL.revokeObjectURL(selectedPreviewUrl); } catch {} }
        selectedPreviewUrl = URL.createObjectURL(f);
        if (mode === 'image') {
          dropArea.innerHTML = `<img class="bg-blur" src="${selectedPreviewUrl}" alt="" decoding="async"><img class="img-main" src="${selectedPreviewUrl}" alt="Original image preview" decoding="async">`;
          statusText.textContent = formatFileNameForDisplay(f.name);
          resultBox.innerHTML = `<div class="upload-circle bg-slate-200 text-slate-600 flex items-center justify-center transition-transform"><span class="material-symbols-outlined text-5xl">visibility_off</span></div><p class="text-xs px-12 text-slate-500">Your anonymized image will appear here</p>`;
        } else {
          dropArea.innerHTML = `<video class="img-main w-full h-full" src="${selectedPreviewUrl}" controls preload="metadata" playsinline webkit-playsinline controlsList="nodownload noremoteplayback"></video>`;
          statusText.textContent = formatFileNameForDisplay(f.name);
          resultBox.innerHTML = `<div class="upload-circle bg-slate-200 text-slate-600 flex items-center justify-center transition-transform"><span class="material-symbols-outlined text-5xl">visibility_off</span></div><p class="text-xs px-12 text-slate-500">Your anonymized video will appear here</p>`;
          try { if (selectedVideoPosterUrl) { URL.revokeObjectURL(selectedVideoPosterUrl); selectedVideoPosterUrl = null; } } catch {}
          const v = dropArea.querySelector('video');
          if (v) {
            v.muted = true;
            v.playsInline = true;
            try {
              capturePosterFromVideoElement(v).then((p) => {
                if (p) {
                  if (typeof p === 'string' && p.startsWith('blob:')) selectedVideoPosterUrl = p;
                  v.setAttribute('poster', p);
                }
              }).catch(() => {});
            } catch {}
          }
        }
        // keep previous downloadable result until next anonymize
        setAnonymizeEnabled(true, false);
        const kind = mode === 'image' ? 'Image' : 'Video';
        toast(`${kind} uploaded`, 'success', 1600);
      }

      

      function renderDropAreaContent() {
        return `
          <div class="upload-circle bg-slate-200 text-slate-600 flex items-center justify-center transition-transform">
            <span class="material-symbols-outlined text-5xl">add_photo_alternate</span>
          </div>
          <div>
            <p class="text-sm font-semibold text-slate-900 dark:text-slate-100">Click or drag image to upload</p>
            <p class="text-xs text-slate-500 mt-1">Supports JPG, PNG, WEBP, BMP, TIFF (Max 10MB)</p>
          </div>
          <input id="fileInput" type="file" accept="image/*" class="hidden" />
        `;
      }
      function renderDropAreaContent() {
        return `
          <div class="upload-circle bg-slate-200 text-slate-600 flex items-center justify-center transition-transform">
            <span class="material-symbols-outlined text-5xl">add_photo_alternate</span>
          </div>
          <div>
            <p class="text-sm font-semibold text-slate-900 dark:text-slate-100">Click or drag an image here</p>
            <p class="text-xs text-slate-500 mt-1">Supported formats: JPG, PNG, WEBP, BMP, TIFF · Max 10 MB</p>
          </div>
          <input id="fileInput" type="file" accept="image/*" class="hidden" />
        `;
      }
      function renderVideoPlaceholderContent() {
        return `
          <div class="upload-circle bg-slate-200 text-slate-600 flex items-center justify-center">
            <span class="material-symbols-outlined text-5xl">movie_filter</span>
          </div>
          <div>
            <p class="text-sm font-semibold text-slate-900 dark:text-slate-100">Click or drag a video here</p>
            <p class="text-xs text-slate-500 mt-1">Supported formats: MP4, MOV, WEBM, AVI · Max 200 MB</p>
          </div>
          <input id="videoInput" type="file" accept="video/mp4,video/webm,video/quicktime,video/x-msvideo,video/hevc" class="hidden" />
        `;
      }
      
      function showToast({ title, message, type = 'info', duration = 4000, noClose = false }) {
        const container = document.getElementById('toastContainer');
        if (!container) return;
        if (type === 'warning') {
          const children = Array.from(container.children);
          for (const c of children) {
            if (c.getAttribute('data-type') === 'warning') {
              c.remove();
            }
          }
        }
        const iconMap = { success: 'check_circle', error: 'cancel', warning: 'warning', info: 'info' };
        const colorClass = type === 'success' ? { bar: 'bg-success', icon: 'text-success' } :
          type === 'error' ? { bar: 'bg-error', icon: 'text-error' } :
          type === 'warning' ? { bar: 'bg-warning', icon: 'text-warning' } :
          { bar: 'bg-info', icon: 'text-info' };
        const el = document.createElement('div');
        el.className = 'toast bg-white dark:bg-slate-900 border border-gray-100 dark:border-slate-800 rounded-lg p-4 ant-shadow flex items-start gap-3 relative overflow-hidden pointer-events-none toast-enter';
        el.setAttribute('role', 'alert');
        el.setAttribute('aria-live', type === 'error' ? 'assertive' : 'polite');
        el.setAttribute('data-type', type);
        el.innerHTML = `
          <div class="absolute top-0 left-0 w-1 h-full ${colorClass.bar}"></div>
          <span class="material-symbols-outlined ${colorClass.icon}">${iconMap[type]}</span>
          <div class="flex-1 toast-body">
            <p class="text-sm font-semibold text-gray-900 dark:text-white">${title}</p>
            <p class="text-xs text-gray-500 dark:text-gray-400 mt-0.5">${message}</p>
          </div>
        `;
        if (!noClose) {
          const btn = document.createElement('button');
          btn.className = 'text-gray-400 hover:text-gray-600 dark:hover:text-gray-200';
          btn.setAttribute('aria-label','Close notification');
          btn.innerHTML = '<span class="material-symbols-outlined text-lg">close</span>';
          el.appendChild(btn);
          try { btn.style.pointerEvents = 'auto'; } catch {}
        }
        const remove = () => {
          el.classList.remove('toast-enter','toast-enter-active');
          el.classList.add('toast-exit','toast-exit-active');
          setTimeout(() => {
            el.remove();
            try {
              const containerNow = document.getElementById('toastContainer');
              if (containerNow && processingToast && processingToast !== el && containerNow.contains(processingToast)) {
                containerNow.prepend(processingToast);
              }
            } catch {}
          }, 200);
        };
        const closeBtn = el.querySelector('button');
        if (closeBtn && !noClose) { closeBtn.addEventListener('click', remove); }
        container.prepend(el);
        requestAnimationFrame(() => {
          el.classList.add('toast-enter-active');
        });
        let timer = null;
        const startTimer = () => {
          if (!noClose && duration && duration > 0) {
            timer = setTimeout(remove, duration);
          }
        };
        const clearTimer = () => { if (timer) { clearTimeout(timer); timer = null; } };
        el.addEventListener('mouseenter', clearTimer);
        el.addEventListener('mouseleave', startTimer);
        el.addEventListener('keydown', (e) => { if (!noClose && e.key === 'Escape') remove(); });
        el.tabIndex = 0;
        startTimer();
        const max = 4;
        const children = Array.from(container.children);
        if (children.length > max) {
          let removed = 0;
          for (let i = children.length - 1; i >= 0 && (children.length - removed) > max; i--) {
            const node = children[i];
            if (processingToast && node === processingToast) continue;
            node.remove();
            removed++;
          }
        }
        el.remove = remove;
        return el;
      }
      function setDownloadEnabled(enabled) {
        if (!downloadBtn) return;
        if (enabled && resultBlobUrl) {
          downloadBtn.classList.remove('cursor-not-allowed','pointer-events-none','text-slate-400','dark:text-slate-500','bg-slate-100','dark:bg-slate-800','border-slate-200','dark:border-slate-700','border-primary','focus:ring-2','focus:ring-primary','focus:ring-offset-2','focus:ring-offset-white','dark:focus:ring-offset-slate-900','hover:bg-primary/90');
          downloadBtn.classList.add('bg-primary','text-on-primary','border','border-slate-900','dark:border-slate-100');
          downloadBtn.removeAttribute('disabled');
          try { downloadBtn.blur(); } catch {}
          if (processingToast && typeof processingToast.remove === 'function') { try { processingToast.remove(); } catch {} processingToast = null; }
          downloadBtn.innerHTML = '<span class="material-symbols-outlined text-[26px]">download</span>Download';
        } else {
          downloadBtn.classList.add('cursor-not-allowed','pointer-events-none','text-slate-400','dark:text-slate-500','bg-slate-100','dark:bg-slate-800','border','border-slate-200','dark:border-slate-700');
          downloadBtn.classList.remove('bg-primary','hover:bg-primary/90','text-on-primary','border-primary','border-slate-900','dark:border-slate-100');
          downloadBtn.setAttribute('disabled','');
          downloadBtn.innerHTML = '<span class="material-symbols-outlined text-[26px]">download</span>Download';
          try { closePreviewOverlay(); } catch {}
        }
      }
      downloadBtn.addEventListener('click', () => {
        if (!resultBlobUrl || downloadBtn.hasAttribute('disabled')) return;
        logMsg('Downloading result...', 'info');
        // iOS Safari doesn't honor the download attribute for Blob URLs
        const ua = (navigator.userAgent || '').toLowerCase();
        const isIOS = /iphone|ipad|ipod/.test(ua);
        const isSafari = /^((?!chrome|android|crios|fxios|edgios).)*safari/.test(ua);
        if (isIOS && isSafari) {
          try {
            window.open(resultBlobUrl, '_blank', 'noopener,noreferrer');
            toast('Opened in a new tab — use Share/Save to download', 'info', 3000);
          } catch {
            const a = document.createElement('a');
            a.href = resultBlobUrl;
            a.target = '_blank';
            a.rel = 'noopener noreferrer';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
          }
        } else {
          const a = document.createElement('a');
          a.href = resultBlobUrl;
          a.download = source === 'image' ? 'anonymized.jpg' : 'anonymized.mp4';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          toast('Downloaded successfully', 'success', 1600);
        }
      });
      (function setupPreviewOverlay(){
        const init = () => {
          const ov = document.getElementById('previewOverlay');
          const inner = document.getElementById('previewInner');
          const img = document.getElementById('previewMediaImg');
          const vid = document.getElementById('previewMediaVideo');
          if (!ov || !inner || !img || !vid) return;
          const close = () => {
            ov.style.display = 'none';
            try { vid.pause(); } catch {}
            try { vid.removeAttribute('src'); vid.load(); } catch {}
          };
          ov.addEventListener('click', (e) => { if (e.target === ov) close(); });
          document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && ov.style.display !== 'none') close(); });
        };
        if (document.readyState === 'complete') {
          init();
        } else {
          window.addEventListener('load', init, { once: true });
        }
      })();
      function closePreviewOverlay() {
        const ov = document.getElementById('previewOverlay');
        const vid = document.getElementById('previewMediaVideo');
        if (!ov) return;
        ov.style.display = 'none';
        try { if (vid) { vid.pause(); vid.removeAttribute('src'); vid.load(); } } catch {}
      }
      function openPreviewOverlayForImage(url) {
        const ov = document.getElementById('previewOverlay');
        const img = document.getElementById('previewMediaImg');
        const vid = document.getElementById('previewMediaVideo');
        if (!ov || !img || !vid || !url) return;
        vid.style.display = 'none';
        try { vid.pause(); vid.removeAttribute('src'); vid.load(); } catch {}
        img.style.display = 'none';
        const onLoad = () => {
          img.removeEventListener('load', onLoad);
          img.removeEventListener('error', onError);
          img.style.display = 'block';
          ov.style.display = 'flex';
        };
        const onError = () => {
          img.removeEventListener('load', onLoad);
          img.removeEventListener('error', onError);
          try { img.removeAttribute('src'); } catch {}
          try { toast('Unable to preview image', 'error', 3000); } catch {}
        };
        img.addEventListener('load', onLoad);
        img.addEventListener('error', onError);
        img.src = url;
      }
      function mapIntensityToBlur(percent) {
        const p = Math.max(5, Math.min(100, Number(percent)));
        return 2 + (p / 100) * 8;
      }
    </script>
    <div id="previewOverlay" style="display:none; position:fixed; inset:0; z-index:60; background:rgba(0,0,0,0.72); align-items:center; justify-content:center; padding:16px;">
    <div id="previewInner" style="max-width:90vw; max-height:90vh;">
      <img id="previewMediaImg" alt="" style="max-width:100%; max-height:90vh; border-radius:12px; display:none;"/>
      <video id="previewMediaVideo" style="max-width:100%; max-height:90vh; border-radius:12px; display:none;" controls playsinline></video>
    </div>
    </div>
  </body>
</html>
